var documenterSearchIndex = {"docs":
[{"location":"IRP/#The-IRP-structures","page":"Inventory Routing Problem","title":"The IRP structures","text":"","category":"section"},{"location":"IRP/#Commodity","page":"Inventory Routing Problem","title":"Commodity","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/commodity.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.Commodity","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.Commodity","text":"Commodity\n\nA commodity (or product) is released by depots, demanded by customers and transported by routes. \n\nWe consider the multi-commodity IRP in this package.\n\nFields\n\nm::Int: index of the commodity.\nl::Int: length of a commodity.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#Base.copy-Tuple{InventoryRoutingLNS.Commodity}","page":"Inventory Routing Problem","title":"Base.copy","text":"Base.copy(commodity::Commodity)\n\nCopy commodity.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Base.show-Tuple{IO, InventoryRoutingLNS.Commodity}","page":"Inventory Routing Problem","title":"Base.show","text":"Base.show(io::IO, commodity::Commodity)\n\nDisplay commodity in the terminal.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Site","page":"Inventory Routing Problem","title":"Site","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/site.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.Site","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.Site","text":"Site\n\nA site is a generic place where inventory is monitored.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#InventoryRoutingLNS.positive_inventory-Tuple{InventoryRoutingLNS.Site}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.positive_inventory","text":"positive_inventory(site::Site)\n\nCheck if the site inventory is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Depot","page":"Inventory Routing Problem","title":"Depot","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/depot.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.Depot","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.Depot","text":"Depot\n\nA depot releases commodities every day.\n\nIn the IRP we plan route deliveries starting at depots in a centralized manner.\n\nFields\n\nd::Int: index of the depot.\nv::Int: index of the site (among depots and customers).\ncoordinates::Tuple{Float64,Float64}: coordinates of the depot.\nexcess_inventory_cost::Vector{Int}: unit excess inventory cost per commodity.\ninitial_inventory::Vector{Int}: initial inventory per commodity.\nproduction::Matrix{Int}: release per commodity and day.\nmaximum_inventory::Matrix{Int}: maximum inventory per commodity and day.\nquantity_sent::Matrix{Int}: quantity sent (with current solution) per commodity and day.\ninventory::Matrix{Int}: inventory (with current solution) per commodity and day.\ncommodity_used::Vector{Bool}: encode the commodities used by the depot.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#Base.copy-Tuple{InventoryRoutingLNS.Depot}","page":"Inventory Routing Problem","title":"Base.copy","text":"Base.copy(depot::Depot)\n\nCopy depot.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Base.show-Tuple{IO, InventoryRoutingLNS.Depot}","page":"Inventory Routing Problem","title":"Base.show","text":"Base.show(io::IO, depot::Depot)\n\nDisplay depot in the terminal.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.renumber-Tuple{InventoryRoutingLNS.Depot}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.renumber","text":"renumber(depot::Depot; d::Int, v::Int)\n\nSet d and v as indices for depot over depots and sites respectively.\n\nThis can be used when dividing an instance into several smaller ones.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Customer","page":"Inventory Routing Problem","title":"Customer","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/customer.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.Customer","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.Customer","text":"Customer\n\nA customer demands commodities every day.\n\nIn the IRP we plan route deliveries to customers in a centralized manner.\n\nFields\n\nc::Int: index of the customer.\nv::Int: index of the site (among depots and customers).\ncoordinates::Tuple{Float64,Float64}: coordinates of the customer.\nexcess_inventory_cost::Vector{Int}: unit excess inventory cost per commodity.\nshortage_cost::Vector{Int}: unit shortage cost per commodity.\ninitial_inventory::Vector{Int}: initial inventory per commodity.\ndemand::Matrix{Int}: demand per commodity and day.\nmaximum_inventory::Matrix{Int}: maximum inventory per commodity and day.\nquantity_received::Matrix{Int}: quantity received (with current solution) per commodity and day.\ninventory::Matrix{Int}: inventory (with current solution) per commodity and day.\ncommodity_used::Vector{Bool}: encode the commodities used by the customer.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#Base.copy-Tuple{InventoryRoutingLNS.Customer}","page":"Inventory Routing Problem","title":"Base.copy","text":"Base.copy(customer::Customer)\n\nCopy customer.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Base.show-Tuple{IO, InventoryRoutingLNS.Customer}","page":"Inventory Routing Problem","title":"Base.show","text":"Base.show(io::IO, customer::Customer)\n\nDisplay customer in the terminal.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.positive_inventory_zero_demand_and_initial_inventory-Tuple{InventoryRoutingLNS.Customer, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.positive_inventory_zero_demand_and_initial_inventory","text":"positive_inventory_zero_demand_and_initial_inventory(customer::Customer, m::Int)\n\nCheck if customer has received some commodity m whereas it does not need it.\n\nIt is used for feasibility tests in feasibility.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.positive_inventory_zero_demand_and_initial_inventory-Tuple{InventoryRoutingLNS.Customer}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.positive_inventory_zero_demand_and_initial_inventory","text":"positive_inventory_zero_demand_and_initial_inventory(customer::Customer)\n\nCheck if customer has received one type of commodity it does not need.\n\nIt is used for feasibility tests in feasibility.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.renumber-Tuple{InventoryRoutingLNS.Customer}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.renumber","text":"renumber(customer::Customer; c::Int, v::Int)\n\nSet c and v as indices for customer over customers and sites respectively.\n\nThis can be used when dividing an instance into several smaller ones.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Route","page":"Inventory Routing Problem","title":"Route","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/route.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.Route","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.Route","text":"Route\n\nA route corresponds to a path and deliveries per customer.\n\nFields\n\nid::Int: id of the route.\nt::Int: start date.\nd::Int: start depot.\nstops::Vector{RouteStop}: stops processed by the route.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#InventoryRoutingLNS.RouteStop","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.RouteStop","text":"RouteStop\n\nStop where a delivery is processed. \n\nFields\n\nc::Int: customer where the stop is made.\nt::Int: arrival day in the stop.\nQ::Vector{Int}: quantities to deliver per commodity.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#Base.copy-Tuple{InventoryRoutingLNS.RouteStop}","page":"Inventory Routing Problem","title":"Base.copy","text":"Base.copy(stop::RouteStop)\n\nCopy route stop.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Base.copy-Tuple{InventoryRoutingLNS.Route}","page":"Inventory Routing Problem","title":"Base.copy","text":"Base.copy(route::Route)\n\nCopy route.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Base.show-Tuple{IO, InventoryRoutingLNS.Route}","page":"Inventory Routing Problem","title":"Base.show","text":"Base.show(io::IO, route::Route)\n\nDisplay route in the terminal.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.check_if_connected-Tuple{Vector{InventoryRoutingLNS.Route}, Vector{InventoryRoutingLNS.Route}}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.check_if_connected","text":"check_if_connected(routes1::Vector{Route}, routes2::Vector{Route})\n\nCheck if two sets of routes are connected by the sites they involve.\n\nTwo sets of routes are connected if they share any site (depot or customer).\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.decouple_routes-Tuple{Vector{InventoryRoutingLNS.Route}}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.decouple_routes","text":"decouple_routes(routes::Vector{Route})\n\nDecouple a set of routes into sets of routes  that do not share any depot or customer.\n\nIt can be used to decompose a MILP into smaller ones. For instance, see refill_routes!.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_M-Tuple{InventoryRoutingLNS.RouteStop}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_M","text":"get_M(stop::RouteStop)\n\nGet the number of commodities M from stop.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_nb_stops-Tuple{InventoryRoutingLNS.Route}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_nb_stops","text":"get_nb_stops(route::Route)\n\nGet the number of (customer) stops of route.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_nb_unique_stops-Tuple{InventoryRoutingLNS.Route}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_nb_unique_stops","text":"get_nb_unique_stops(route::Route)\n\nGet the number of distinct (customer) stops of route.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.mycopy-Tuple{InventoryRoutingLNS.RouteStop}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.mycopy","text":"mycopy(stop::RouteStop)\n\nCustom copy of a route stop.\n\nThis is currently used in routing neighborhoods.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.mycopy-Tuple{InventoryRoutingLNS.Route}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.mycopy","text":"mycopy(route::Route)\n\nCustom copy of route.\n\nThis is currently used in routing neighborhoods.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.mycopy-Tuple{Vector{InventoryRoutingLNS.RouteStop}}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.mycopy","text":"mycopy(stops::Vector{RouteStop})\n\nCustom copy of a vector of route stops.\n\nThis is currently used in routing neighborhoods.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.unique_stops-Tuple{InventoryRoutingLNS.Route}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.unique_stops","text":"unique_stops(route::Route)\n\nGet the set of customer indices visited by route.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.unique_stops-Tuple{Vector{InventoryRoutingLNS.Route}}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.unique_stops","text":"unique_stops(routes::Vector{Route})\n\nGet the set of customer indices visited by the set of routes.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.uses_commodity-Tuple{InventoryRoutingLNS.Route, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.uses_commodity","text":"uses_commodity(route::Route, m::Int)\n\nCheck if commodity m is delivered to any stop visited by route.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.uses_commodity-Tuple{InventoryRoutingLNS.RouteStop, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.uses_commodity","text":"uses_commodity(stop::RouteStop, m::Int)\n\nCheck if commodity m is delivered to stop.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Solution","page":"Inventory Routing Problem","title":"Solution","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/solution.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.Solution","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.Solution","text":"Solution\n\nAbstract IRP solution.\n\nA solution gathers routes in different ways. See SimpleSolution or StructuredSolution.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#Base.show-Tuple{IO, InventoryRoutingLNS.Solution}","page":"Inventory Routing Problem","title":"Base.show","text":"Base.show(io::IO, solution::Solution)\n\nDisplay solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Simple-Solution","page":"Inventory Routing Problem","title":"Simple Solution","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/solution_simple.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.SimpleSolution","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.SimpleSolution","text":"SimpleSolution\n\nIRP solution as vector of routes.\n\nFields\n\nroutes::Vector{Route}: routes of the solution.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#InventoryRoutingLNS.add_route!-Tuple{InventoryRoutingLNS.SimpleSolution, InventoryRoutingLNS.Route}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.add_route!","text":"add_route!(solution::SimpleSolution, route::Route)\n\nAdd route to a simple solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.delete_route!-Tuple{InventoryRoutingLNS.SimpleSolution, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.delete_route!","text":"delete_route!(solution::SimpleSolution, r::Int)\n\nDelete the route at index r from a simple solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.list_routes-Tuple{InventoryRoutingLNS.SimpleSolution, Int64, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.list_routes","text":"list_routes(solution::SimpleSolution, t::Int, d::Int)\n\nGet the list of routes starting on day t from depot d in a simple solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.list_routes-Tuple{InventoryRoutingLNS.SimpleSolution, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.list_routes","text":"list_routes(solution::SimpleSolution, t::Int)\n\nGet the list of routes starting on day t in a simple solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.list_routes-Tuple{InventoryRoutingLNS.SimpleSolution}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.list_routes","text":"list_routes(solution::SimpleSolution)\n\nGet the list of routes in a simple solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.nb_routes-Tuple{InventoryRoutingLNS.SimpleSolution}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.nb_routes","text":"nb_routes(solution::SimpleSolution)\n\nGet the number of routes in a simple solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Structured-Solution","page":"Inventory Routing Problem","title":"Structured Solution","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/solution_structured.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.StructuredSolution","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.StructuredSolution","text":"StructuredSolution\n\nIRP solution as matrix of routes per day and depot.\n\nFields\n\nroutes_per_day_and_depot::Matrix{Vector{Route}}: routes of the solution.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#Base.copy-Tuple{InventoryRoutingLNS.StructuredSolution}","page":"Inventory Routing Problem","title":"Base.copy","text":"Base.copy(solution::StructuredSolution)\n\nCopy structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.add_route!-Tuple{InventoryRoutingLNS.StructuredSolution, InventoryRoutingLNS.Route}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.add_route!","text":"add_route!(solution::StructuredSolution, route::Route)\n\nPush route to a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.add_route!-Tuple{InventoryRoutingLNS.StructuredSolution, Vector{InventoryRoutingLNS.Route}}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.add_route!","text":"add_route!(solution::StructuredSolution, routes::Vector{Route})\n\nPush a set routes to a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.delete_route!-Tuple{InventoryRoutingLNS.StructuredSolution, Int64, Int64, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.delete_route!","text":"delete_route!(solution::StructuredSolution, t::Int, d::Int, r::Int)\n\nDelete the r-th route starting on day t by depot d from a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.delete_route!-Tuple{InventoryRoutingLNS.StructuredSolution, InventoryRoutingLNS.Route}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.delete_route!","text":"delete_route!(solution::StructuredSolution, route::Route)\n\nDelete route from a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.delete_routes!-Tuple{InventoryRoutingLNS.StructuredSolution, Int64, Int64, Any}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.delete_routes!","text":"delete_routes!(solution::StructuredSolution, t::Int, d::Int, rs)\n\nDelete the rs-th routes starting on day t by depot d from a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.delete_routes!-Tuple{InventoryRoutingLNS.StructuredSolution, Vector{InventoryRoutingLNS.Route}}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.delete_routes!","text":"delete_routes!(solution::StructuredSolution, routes::Vector{Route})\n\nDelete a set routes from a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_D-Tuple{InventoryRoutingLNS.StructuredSolution}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_D","text":"get_D(solution::StructuredSolution)\n\nGet the number of depots D from the structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_T-Tuple{InventoryRoutingLNS.StructuredSolution}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_T","text":"get_T(solution::StructuredSolution)\n\nGet the horizon T from the structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_route-Tuple{InventoryRoutingLNS.StructuredSolution, Int64, Int64, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_route","text":"get_route(solution::StructuredSolution, t::Int, d::Int, r::Int)\n\nGet the r-th route starting on day t by depot d in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_route_day-Tuple{InventoryRoutingLNS.StructuredSolution, Int64, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_route_day","text":"get_route_day(solution::StructuredSolution, t::Int, r::Int)\n\nGet the r-th route starting on day t in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_route_depot-Tuple{InventoryRoutingLNS.StructuredSolution, Int64, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_route_depot","text":"get_route_depot(solution::StructuredSolution, d::Int, r::Int)\n\nGet the r-th route starting by depot d in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.list_routes-Tuple{InventoryRoutingLNS.StructuredSolution, Int64, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.list_routes","text":"list_routes(solution::StructuredSolution, t::Int, d::Int)\n\nGet the list of routes starting on day t from depot d in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.list_routes-Tuple{InventoryRoutingLNS.StructuredSolution, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.list_routes","text":"list_routes(solution::StructuredSolution, t::Int)\n\nGet the list of routes starting on day t in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.list_routes-Tuple{InventoryRoutingLNS.StructuredSolution}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.list_routes","text":"list_routes(solution::StructuredSolution)\n\nGet the list of routes of a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.list_routes_customer-Tuple{InventoryRoutingLNS.StructuredSolution, Int64, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.list_routes_customer","text":"list_routes_customer(solution::StructuredSolution, c::Int, t::Int)\n\nGet the list of routes visiting customer c and starting on day t in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.list_routes_customer-Tuple{InventoryRoutingLNS.StructuredSolution, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.list_routes_customer","text":"list_routes_customer(solution::StructuredSolution, c::Int)\n\nGet the list of routes visiting customer c in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.list_routes_depot-Tuple{InventoryRoutingLNS.StructuredSolution, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.list_routes_depot","text":"list_routes_depot(solution::StructuredSolution, d::Int)\n\nGet the list of routes starting by depot d in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.mycopy-Tuple{InventoryRoutingLNS.StructuredSolution}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.mycopy","text":"mycopy(solution::StructuredSolution)\n\nCustom copy of a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.nb_routes-Tuple{InventoryRoutingLNS.StructuredSolution, Int64, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.nb_routes","text":"nb_routes(solution::StructuredSolution, t::Int, d::Int)\n\nCompute the number of routes starting on day t from depot d in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.nb_routes-Tuple{InventoryRoutingLNS.StructuredSolution, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.nb_routes","text":"nb_routes(solution::StructuredSolution, t::Int)\n\nCompute the number of routes starting on day t in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.nb_routes-Tuple{InventoryRoutingLNS.StructuredSolution}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.nb_routes","text":"nb_routes(solution::StructuredSolution)\n\nCompute the number of routes in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.nb_routes_customer-Tuple{InventoryRoutingLNS.StructuredSolution, Int64, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.nb_routes_customer","text":"nb_routes_customer(solution::StructuredSolution, t::Int, c::Int)\n\nCompute the number of routes that visit customer c and start on day t in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.nb_routes_depot-Tuple{InventoryRoutingLNS.StructuredSolution, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.nb_routes_depot","text":"nb_routes_depot(solution::StructuredSolution, d::Int)\n\nCompute the number of routes starting from depot d in a structured solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Instance","page":"Inventory Routing Problem","title":"Instance","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/instance.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.Instance","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.Instance","text":"Instance\n\nAn IRP instance gathers all information needed to define the problem.\n\nCommodities, depots, customers, time and transport information is stored here. A solution can also be saved.\n\nFields\n\nT::Int: horizon.\nD::Int: number of depots.\nC::Int: number of customers.\nM::Int: number of commodities.\nvehicle_capacity::Int: capacity of a vehicle (1D).\nkm_cost::Int: unit kilometer cost.\nvehicle_cost::Int: cost of making a stop for a delivery.\nstop_cost::Int: cost for using a vehicle.\nnb_transport_hours_per_day::Int: number of transport hours possible in a day.\nS_max::Int: maximum number of stops in a route. \ncommodities::Vector{Commodity}: the commodities.\ndepots::Vector{Depot}: the depots.\ncustomers::Vector{Customer}: the customers.\ndist::Matrix{Int}: distances between sites in kilometers.\ntransport_durations::Matrix{Int}: durations between sites in hours.\nsolution::StructuredSolution: current solution of the instance.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#Base.copy-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"Base.copy","text":"Base.copy(instance::Instance)\n\nCopy instance.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Base.show-Tuple{IO, InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"Base.show","text":"Base.show(io::IO, instance::Instance)\n\nDisplay instance in the terminal.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.commodities_used_customer-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.commodities_used_customer","text":"commodities_used_customer(instance::Instance, c::Int)\n\nSelect the commodities with positive initial inventory  or positive cumulated demand over the horizon at customer c.\n\nIt is used in the customer reinsertion large neighborhood.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.commodities_used_depot-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.commodities_used_depot","text":"commodities_used_depot(instance::Instance, d::Int)\n\nSelect the commodities with positive initial inventory  or positive cumulated release over the horizon at depot d.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_nb_km-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_nb_km","text":"compute_nb_km(route::Route, instance::Instance)\n\nCompute the number of kilometers travelled along route.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_route_duration-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_route_duration","text":"compute_route_duration(route::Route, instance::Instance)\n\nCompute the total duration of route in hours.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.content_size-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.content_size","text":"content_size(route::Route, instance::Instance)\n\nCompute the space used in the 1D vehicle of route by all stops deliveries.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.content_size-Tuple{InventoryRoutingLNS.RouteStop, InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.content_size","text":"content_size(stop::RouteStop, instance::Instance)\n\nCompute the 1D space occupied by the quantities to be sent to stop.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_vehicle_cost-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_vehicle_cost","text":"get_vehicle_cost(instance::Instance)\n\nGet the vehicle cost data of instance.\n\nIt is used in the cost functions as compute_route_cost.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.ratio_demanded_released-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.ratio_demanded_released","text":"ratio_demanded_released(instance::Instance)\n\nEstimate the ratio quantity released/quantity demanded per commodity.\n\nWe use it as ratio to rescale unbalanced instances  in rescale_release_demand! to test algorithms.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.rescale_release_demand!-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.rescale_release_demand!","text":"rescale_release_demand!(instance::Instance; verbose::Bool = false)\n\nRescale instance demand and release.\n\nThe aim is to have total demand close to total release. Instances with  this property are more difficult to solve. \n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.routes_to_sent_quantities-Tuple{InventoryRoutingLNS.SimpleSolution, InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.routes_to_sent_quantities","text":"routes_to_sent_quantities(solution::SimpleSolution, instance::Instance)\n\nDeduce the quantities sent from each depot to each customer  per commodity and per day from a simple solution (set of routes).\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.routes_to_sent_quantities-Tuple{InventoryRoutingLNS.StructuredSolution, InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.routes_to_sent_quantities","text":"routes_to_sent_quantities(solution::StructuredSolution, instance::Instance)\n\nDeduce the quantities sent from each depot to each customer  per commodity and per day from solution (set of routes).\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.select_relevant_customers-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.select_relevant_customers","text":"select_relevant_customers(instance::Instance, m::Int)\n\nSelect the customers having positive initial inventory  or positive cumulated demand over the horizon in commodity m.\n\nIt is used in the graph creation in commodity_flow_graph to sparsify.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.select_relevant_depots-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.select_relevant_depots","text":"select_relevant_depots(instance::Instance, m::Int)\n\nSelect the depots having positive initial inventory  or positive cumulated release over the horizon in commodity m.\n\nIt is used in the graph creation in commodity_flow_graph to sparsify.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#Analysis","page":"Inventory Routing Problem","title":"Analysis","text":"","category":"section"},{"location":"IRP/","page":"Inventory Routing Problem","title":"Inventory Routing Problem","text":"Modules = [InventoryRoutingLNS]\nPages = [\"IRP/analysis.jl\"]","category":"page"},{"location":"IRP/#InventoryRoutingLNS.AverageContentSizes","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.AverageContentSizes","text":"AverageContentSizes\n\nGather the average content size in the routes of a solution per depot, day and customer. \n\nDesigned to be passed as argument in the second pass of the greedy heuristic  modified_capa_initialization_plus_ls!.\n\nFields\n\navg_l_d::Vector{Float64}: average content size per depot.\navg_l_c::Vector{Float64}: average content size per customer.\navg_l_t::Vector{Float64}: average content size per day.\n\n\n\n\n\n","category":"type"},{"location":"IRP/#InventoryRoutingLNS.compute_average_content_size-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_average_content_size","text":"compute_average_content_size(instance::Instance)\n\nCompute the average content size over the routes in the solution of instance.\n\nThis information can be used as a metric to estimate a solution quality.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_average_content_size_customer-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_average_content_size_customer","text":"compute_average_content_size_customer(instance::Instance)\n\nCompute the average content size over the routes that visit each depot in the solution of instance.\n\nReturn a vector with one value per customer. This information is used for the second path of  the modified_capa_initialization_plus_ls! to estimate the flow arcs' cost.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_average_content_size_day-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_average_content_size_day","text":"compute_average_content_size_day(instance::Instance)\n\nCompute the average content size over the routes that start on each day in the solution of instance.\n\nReturn a vector with one value per day. This information is used for the second path of  the modified_capa_initialization_plus_ls! to estimate the flow arcs' cost.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_average_content_size_depot-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_average_content_size_depot","text":"compute_average_content_size_depot(instance::Instance)\n\nCompute the average content size over the routes that start from each depot in the solution of instance.\n\nReturn a vector with one value per depot. This information is used for the second path of  the modified_capa_initialization_plus_ls! to estimate the flow arcs' cost.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_average_nb_km-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_average_nb_km","text":"compute_average_nb_km(instance::Instance)\n\nCompute the average number of kilometers of the routes in the solution of instance.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_average_route_duration-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.SimpleSolution}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_average_route_duration","text":"compute_average_route_duration(instance::Instance, solution::SimpleSolution)\n\nCompute the average duration in hours of the routes in solution for instance.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_average_route_duration-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_average_route_duration","text":"compute_average_route_duration(instance::Instance)\n\nCompute the average duration in hours of the routes in the solution of instance.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_avg_nb_stops-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_avg_nb_stops","text":"compute_avg_nb_stops(instance::Instance)\n\nCompute the average number of stops over the routes in the solution of instance.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.compute_route_durations-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.SimpleSolution}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.compute_route_durations","text":"compute_route_durations(instance::Instance, solution::SimpleSolution)\n\nCompute the vector of route durations, one element per route of solution.\n\n\n\n\n\n","category":"method"},{"location":"IRP/#InventoryRoutingLNS.get_most_expensive_customers-Tuple{InventoryRoutingLNS.Instance}","page":"Inventory Routing Problem","title":"InventoryRoutingLNS.get_most_expensive_customers","text":"get_most_expensive_customers(instance::Instance)\n\nGet the indices of the customers sorted by their costs in the solution.\n\nThe cost of a customer is computed as the sum of the inventory compute_inventory_cost and  shortage compute_shortage_cost costs.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Utility-functions","page":"Utils","title":"Utility functions","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Modules = [InventoryRoutingLNS]\nPages = [\"utils/combinatorics.jl\", \"utils/manage_time.jl\"]","category":"page"},{"location":"utils/#InventoryRoutingLNS.HEAP_TRANSPOSITIONS","page":"Utils","title":"InventoryRoutingLNS.HEAP_TRANSPOSITIONS","text":"HEAP_TRANSPOSITIONS\n\nConstant list the transpositions necessary to enumerate all permutations of 1:k.\n\nComputed for k in 1:4 only.\n\n\n\n\n\n","category":"constant"},{"location":"utils/#InventoryRoutingLNS.heap_permutations!-Tuple{Any}","page":"Utils","title":"InventoryRoutingLNS.heap_permutations!","text":"heap_permutations!(a)\n\nEnumerate all permutations of a in-place and print them.\n\n\n\n\n\n","category":"method"},{"location":"utils/#InventoryRoutingLNS.heap_transpositions-Tuple{Int64}","page":"Utils","title":"InventoryRoutingLNS.heap_transpositions","text":"heap_transpositions(k::Int)\n\nList the transpositions necessary to enumerate all permutations of 1:k.\n\nLightweight implementation of Heap's algorithm.\n\n\n\n\n\n","category":"method"},{"location":"utils/#InventoryRoutingLNS.compute_total_time-Tuple{Dict}","page":"Utils","title":"InventoryRoutingLNS.compute_total_time","text":"compute_total_time(stats::Dict)\n\nCompute the duration in minutes elapsed since the beginning of the solution process.\n\nThe dictionnary stats stores statistics on the run.\n\n\n\n\n\n","category":"method"},{"location":"flows/#Graphs-and-flows","page":"Flows and Graphs","title":"Graphs and flows","text":"","category":"section"},{"location":"flows/#FlowGraphs","page":"Flows and Graphs","title":"FlowGraphs","text":"","category":"section"},{"location":"flows/","page":"Flows and Graphs","title":"Flows and Graphs","text":"Modules = [InventoryRoutingLNS]\nPages = [\"flows/graph_format.jl\"]","category":"page"},{"location":"flows/#InventoryRoutingLNS.FGN","page":"Flows and Graphs","title":"InventoryRoutingLNS.FGN","text":"FGN\n\nA flow graph node represents a wide array of concepts to define flow graphs.\n\nThis structure is a central block of the FlowGraph used to build commodity and  vehicle flow graphs in commodity_flow_graph and expanded_vehicle_flow_graph for instance.  \n\nFields\n\nt::Int: date, by default 0.\nt_h::Int: hour (not used in current version), by default 0.\nd::Int: depot index, by default 0.\nc::Int: customer index, by default 0.\ns::Int: stop index, by default 0.\nstr::String: string to mention a concept, by default \"?\".\n\n\n\n\n\n","category":"type"},{"location":"flows/#InventoryRoutingLNS.FlowGraph","page":"Flows and Graphs","title":"InventoryRoutingLNS.FlowGraph","text":"FlowGraph{L}\n\nFlow graph storage with labeled vertices and ordered edges that have capacities and costs.\n\nThis structure is used to build commodity and vehicle flow graphs in commodity_flow_graph and expanded_vehicle_flow_graph for instance. It is based on the Graph.jl package.\n\nFields\n\nvertexlabels::Vector{L}: vector of the vertex labels. \nvertexindices::Dict{L,Int}: correspondance between vertex labels and indices.\ninneighbors::Vector{Vector{Int}}: one vector of inneighbors indices per vertex index.\noutneighbors::Vector{Vector{Int}}: one vector of outneighbors indices per vertex index.\nedges::Vector{Graphs.SimpleEdge{Int}}: vector of edges.\nedgeindices::Dict{Graphs.SimpleEdge{Int},Int}: correspondance between edges and edgeindices.\ncapa_min::Vector{Float64}: minimum capacity vector (on edges).\ncapa_max::Vector{Float64}: maximum capacity vector (on edges).\ncost::Vector{Float64}: cost vector (on edges).\n\n\n\n\n\n","category":"type"},{"location":"flows/#InventoryRoutingLNS.add_flow_constraints!-Tuple{JuMP.Model, Any, InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_flow_constraints!","text":"add_flow_constraints!(model::Model, flowvar, g::FlowGraph)\n\nAdd flow constraints to variable flowvar of a JuMP model, based on flow graph g.\n\nThe flow constraints are the following:\n\nminimum and maximum capacity constraints on all the arcs.\nKirchhoff constraint for the flow conservation.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_flow_cost!-Tuple{Any, Any, InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_flow_cost!","text":"add_flow_cost!(expr, flowvar, g::FlowGraph)\n\nAdd flow cost of variable flowvar to JuMP expression expr, based on flow graph g.\n\n\n\n\n\n","category":"method"},{"location":"flows/#Commodity-flow-graphs","page":"Flows and Graphs","title":"Commodity flow graphs","text":"","category":"section"},{"location":"flows/","page":"Flows and Graphs","title":"Flows and Graphs","text":"Modules = [InventoryRoutingLNS]\nPages = [\"flows/commodity_graph.jl\",\n\"flows/commodity_graph_single_customer.jl\"]","category":"page"},{"location":"flows/#InventoryRoutingLNS.add_artificial_nodes_CFG!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_artificial_nodes_CFG!","text":"add_artificial_nodes_CFG!(fg::FlowGraph; refill_neighborhood::Bool)\n\nAdd the artificial nodes to the commodity flow graph fg.\n\nThese artificial nodes are used to build a flow problem.\n\nThe source and sink nodes enable a circulation.\nproduction is a way to model and force the value of depots release with capacitated arcs.\ndemand does the same for the customers demand.\ninitial_inventory enables to set the initial inventory at each depot and each customer.\nshortage_compensation is a way to model the shortage costs in the flow.\nfinal_inventory gathers the inventory at each site in the end of the horizon T.\nother_received_quantities and other_sent_quantities are only created    when the boolean refill_neighborhood is true. This is done when defining    a large neighborhood MILP with fill_fixed_routes_MILP.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_customer_inventory_arcs_CFG!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_customer_inventory_arcs_CFG!","text":"add_customer_inventory_arcs_CFG!(fg::FlowGraph;\n                                    instance::Instance,\n                                    commodity_index::Int,\n                                    list_customers::AbstractVector{Int},\n                                    S_max::Int,\n)\n\nAdd the arcs corresponding to the customers inventory dynamics.\n\nThanks to the free_night nodes we manage to model the excess inventory costs. We create on each day:\n\none arc from morning to evening without cost or capacity.\none arc from evening to free_night with cost or capacity.\none arc from evening to morning of next day with unit excess_inventory_cost and no capacity.\none arc from free_night to morning of next day with capacity maximum_inventory.\none arc from each noon node to evening to connect the possible positions in new    routes with the inventory dynamics.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_cycle_arcs_CFG!-Tuple{InventoryRoutingLNS.FlowGraph, Bool}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_cycle_arcs_CFG!","text":"add_cycle_arcs_CFG!(fg::FlowGraph, refill_neighborhood::Bool)\n\nAdd the arcs between artificial nodes to create the circulation.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_depots_inventory_arcs_CFG!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_depots_inventory_arcs_CFG!","text":"add_depots_inventory_arcs_CFG!(fg::FlowGraph;\n                                instance::Instance,\n                                commodity_index::Int,\n                                list_depots::AbstractVector{Int},\n)\n\nAdd the arcs corresponding to the depots inventory dynamics.\n\nThanks to the free_night nodes we manage to model the excess inventory costs. We create on each day:\n\none arc from morning to evening without cost or capacity.\none arc from evening to free_night with cost or capacity.\none arc from evening to morning of next day with unit excess_inventory_cost and no capacity.\none arc from free_night to morning of next day with capacity maximum_inventory.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_every_day_nodes_CFG!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_every_day_nodes_CFG!","text":"add_every_day_nodes_CFG!(fg::FlowGraph;\n                            instance::Instance,\n                            list_depots::AbstractVector{Int},\n                            list_customers::AbstractVector{Int},\n                            S_max::Int,\n)\n\nAdd the daily inventory nodes to the commodity flow graph.\n\nWe update fg with new nodes:\n\nOne morning and evening node on each day t for each site.   We remind that demand, release and routes departures occur in the morning,   whereas routes arrival in the evening. \nOne free_night node on each day to incorporate the excess inventory costs.\nOne noon node for each position in a new route for the customers.   Most of the time S_max is 1(in this function, not in instance data) and only one    position is considered: in this case we plan to build new direct routes.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_fixed_routes_arcs_CFG!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_fixed_routes_arcs_CFG!","text":"add_fixed_routes_arcs_CFG!(fg::FlowGraph;\n                            instance::Instance,\n                            fixed_routes::Vector{Route},\n                            commodity_index::Int,\n                            force_routes_values::Bool,\n)\n\nAdd the arcs corresponding to the fixed_routes paths.\n\nThis function is used to integrate some routes with pre-defined  paths in the flow solution. We add the nodes and arcs corresponding  to those paths, and connect them to the starting depots and to the  evening of the customers visited.  It is particularly useful in fill_fixed_routes_MILP.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_initial_final_inventory_arcs_CFG!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_initial_final_inventory_arcs_CFG!","text":"add_initial_final_inventory_arcs_CFG!(fg::FlowGraph;\n                                        instance::Instance,\n                                        commodity_index::Int,\n                                        list_depots::AbstractVector{Int},\n                                        list_customers::AbstractVector{Int},\n)\n\nAdd arcs between the artificial nodes and initial and final inventory nodes.\n\nThe arcs from initial_inventory to the morning of the first day are used to set the initial inventories to the values stored in instance.  The final inventories are aggregated for clarity and could be used to add final  inventory costs for instance.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_new_routes_arcs_CFG!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_new_routes_arcs_CFG!","text":"add_new_routes_arcs_CFG!(fg::FlowGraph;\n                            instance::Instance,\n                            list_depots::AbstractVector{Int},\n                            list_customers::AbstractVector{Int},\n                            commodity_index::Int,\n                            maxdist::Real,\n                            relaxed_trip_cost::Bool,\n                            average_content_sizes::Union{Nothing,AverageContentSizes},\n                            S_max::Int,\n                            force_routes_values::Bool,\n                            sent_quantities_to_force::Array,\n                            set_upper_capa::Bool,\n                            possible_delays::Dict,\n                            add_delayed_arcs::Bool,\n)\n\nAdd the arcs corresponding to new routes.\n\nThe maxdist argument is used to sparsify the graph, removing arcs corresponding to long distances. \n\nWhen the boolean relaxed_trip_cost is true, we add costs on  the routing arcs of the commodity flow graphs. This is done in a heurisic  way in initialization_plus_ls! with vehicle fraction costs, and based on  the statistics (saved in average_content_sizes) of a first solution  in a second pass in modified_capa_initialization_plus_ls!. When used in one_step_ruin_recreate_commodity! or fill_fixed_routes_MILP,  no cost is set on those routing arcs of the commodity flow graphs.\n\nWe enable forcing the quantities to send through the routes with the boolean force_routes_values and quantities sent_quantities_to_force.  This is done to initialize the flow solution with the value deduced from  the current IRP solution, to speed-up computations. This is done in one_step_ruin_recreate_commodity!.\n\nFor some applications in Machine Learning, we need to define a flow  on a polytope (bounded) and thus to derive some upper capacities  on the routing arcs. This is done when set_upper_capa is true.\n\nLast, to derive a flow relaxation of the IRP, we need to add  delayed arcs in the commodity flow graphs, which is done when  add_delayed_arcs is true. In this case the direct delayed arcs  have precomputed delays saved in possible_delays. The implementation of the relaxation is done in lower_bound. \n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_production_arcs_depots_CFG!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_production_arcs_depots_CFG!","text":"add_production_arcs_depots_CFG!(fg::FlowGraph;\n                                instance::Instance,\n                                commodity_index::Int,\n                                list_depots::AbstractVector{Int},\n                                refill_neighborhood::Bool,\n)\n\nAdd the arcs corresponding to release and quantities to send to other customers.\n\nWe use the arcs from production to the morning of each day to set the release of each customer in accordance with the data stored in instance. Besides, since we possibly fix a part of the solution when refill_neighborhood is true,  the arcs to other_sent_quantities nodes are used to take the  other deliveries into account in the inventory dynamics of the depots.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_shortage_demand_arcs_customer_CFG!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_shortage_demand_arcs_customer_CFG!","text":"add_shortage_demand_arcs_customer_CFG!(fg::FlowGraph;\n                                        instance::Instance,\n                                        commodity_index::Int,\n                                        list_customers::AbstractVector{Int},\n                                        refill_neighborhood::Bool,\n)\n\nAdd the arcs corresponding to demand, shortage and quantities received.\n\nAs for the release, the arcs from each morning to the node demand are used to fix the demand in accordance with the data of instance. Besides, we create arcs from the node shortage_compensation to each morning  node with shortage cost to model the soft minimum inventory constraint.  Last, when refill_neighborhood is true, we also create arcs from other_received_quantities to morning nodes to take the rest of the current solution into account.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.commodity_flow_graph-Tuple{InventoryRoutingLNS.Instance}","page":"Flows and Graphs","title":"InventoryRoutingLNS.commodity_flow_graph","text":"commodity_flow_graph(instance::Instance;\n                        commodity_index::Int,\n                        add_new_routes_arcs::Bool = true,\n                        S_max::Int = 1,\n                        maxdist::Real = Inf,\n                        relaxed_trip_cost::Bool = true,\n                        average_content_sizes::Union{Nothing,AverageContentSizes} = nothing,\n                        force_routes_values::Bool = false,\n                        sent_quantities_to_force::Array = zeros(1),\n                        sparsify::Bool = true,\n                        set_upper_capa::Bool = false,\n                        possible_delays::Dict = Dict(),\n                        add_delayed_arcs::Bool = false,\n                        fixed_routes::Union{Nothing, Vector{Route}} = nothing,\n                        refill_neighborhood::Bool = false,\n)\n\nCreate the commodity flow graph corresponding to commodity_index.\n\nWhen add_new_routes_arcs is true, we add the arcs corresponding to new  routes with add_new_routes_arcs_CFG!.\n\nThe argument S_max is used to restrict the length of the new routes to create. It is currently systematically set to 1. See initialization_plus_ls! and  one_step_ruin_recreate_commodity! for instance. \n\nThe maxdist argument is used to sparsify the graph, removing arcs corresponding to long distances.\n\nWhen sparsify is true, we restrict the nodes to the customers and depots that are concerned by the commodity with index commodity_index. We emphasize in this  case the indices of the nodes and arcs differ from one commodity flow graph to  the other, which makes it difficult to combine them for instance in  fill_fixed_routes_MILP. We may thus disable this sparsification  and force zero values in this case. \n\nWhen the boolean relaxed_trip_cost is true, we add costs on  the routing arcs of the commodity flow graphs. This is done in a heurisic  way in initialization_plus_ls! with vehicle fraction costs, and based on  the statistics (saved in average_content_sizes) of a first solution  in a second pass in modified_capa_initialization_plus_ls!. When used in one_step_ruin_recreate_commodity! or fill_fixed_routes_MILP,  no cost is set on those routing arcs of the commodity flow graphs.\n\nWe enable forcing the quantities to send through the routes with the boolean force_routes_values and quantities sent_quantities_to_force.  This is done to initialize the flow solution with the value deduced from  the current IRP solution, to speed-up computations. This is done in one_step_ruin_recreate_commodity!.\n\nFor some applications in Machine Learning, we need to define a flow  on a polytope (bounded) and thus to derive some upper capacities  on the routing arcs. This is done when set_upper_capa is true.\n\nTo derive a flow relaxation of the IRP, we need to add  delayed arcs in the commodity flow graphs, which is done when  add_delayed_arcs is true. In this case the direct delayed arcs  have precomputed delays saved in possible_delays. The implementation of the relaxation is done in lower_bound. \n\nLast, as stated before, this graph structure can be used and combined  in the fill_fixed_routes_MILP function, possibly to derive  a large neighborhood when the boolean refill_neighborhood is true. In this case we provide the fixed_routes to add in add_fixed_routes_arcs_CFG!.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_artificial_nodes_CFGC!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_artificial_nodes_CFGC!","text":"add_artificial_nodes_CFGC!(fg::FlowGraph)\n\nAdd the artificial nodes to the commodity flow graph fg of a customer.\n\nThese artificial nodes are used to build a flow problem.\n\nThe source and sink nodes enable a circulation.\nproduction is a way to model and force the value of depots release with capacitated arcs.\ndemand does the same for the customers demand.\ninitial_inventory enables to set the initial inventory at each depot and each customer.\nshortage_compensation is a way to model the shortage costs in the flow.\ndelivery_other_customers enables to fix the quantities to be sent by depots to other customers than the one being inserted.\nfinal_inventory gathers the inventory at each site in the end of the horizon T.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_customer_inventory_arcs_CFGC!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_customer_inventory_arcs_CFGC!","text":"add_customer_inventory_arcs_CFGC!(fg::FlowGraph;\n                                    instance::Instance,\n                                    customer_index::Int,\n                                    commodity_index::Int,\n)\n\nAdd the arcs corresponding to the customer customer_index inventory dynamics.\n\nThanks to the free_night nodes we manage to model the excess inventory costs. We create on each day:\n\none arc from morning to evening without cost or capacity.\none arc from evening to free_night with cost or capacity.\none arc from evening to morning of next day with unit excess_inventory_cost and no capacity.\none arc from free_night to morning of next day with capacity maximum_inventory.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_cycle_arcs_CFGC!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_cycle_arcs_CFGC!","text":"add_cycle_arcs_CFGC!(fg::FlowGraph)\n\nAdd the arcs between artificial nodes to create the circulation.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_depots_inventory_arcs_CFGC!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_depots_inventory_arcs_CFGC!","text":"add_depots_inventory_arcs_CFGC!(fg::FlowGraph;\n                                instance::Instance,\n                                commodity_index::Int,\n)\n\nAdd the arcs corresponding to the depots inventory dynamics.\n\nThanks to the free_night nodes we manage to model the excess inventory costs. We create on each day:\n\none arc from morning to evening without cost or capacity.\none arc from evening to free_night with cost or capacity.\none arc from evening to morning of next day with unit excess_inventory_cost and no capacity.\none arc from free_night to morning of next day with capacity maximum_inventory.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_every_day_nodes_CFGC!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_every_day_nodes_CFGC!","text":"add_every_day_nodes_CFGC!(fg::FlowGraph;\n                            instance::Instance,\n                            customer_index::Int,\n                            routes::Vector{Route},\n                            dates::Vector,\n                            costs::Vector,    \n)\n\nAdd the daily inventory nodes to the commodity flow graph of a customer.\n\nWe update fg with new nodes:\n\nOne morning and evening node on each day t for each site. We remind that demand,    release and routes departures occur in the morning, whereas routes arrival in the evening. \nOne free_night node on each day to incorporate the excess inventory costs.\nOne node per possible position of the customer to insert in the routes.    This means saving the arrival dates for each position in dates.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_initial_final_inventory_arcs_CFGC!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_initial_final_inventory_arcs_CFGC!","text":"add_initial_final_inventory_arcs_CFGC!(fg::FlowGraph;\n                                        instance::Instance,\n                                        customer_index::Int,\n                                        commodity_index::Int,\n)\n\nAdd arcs between the artificial nodes and initial and final inventory nodes.\n\nThe arcs from initial_inventory to the morning of the first day are used to set the initial inventories to the values stored in instance.  The final inventories are aggregated for clarity and could be used to add final  inventory costs for instance.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_production_delivery_arcs_depots_CFGC!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_production_delivery_arcs_depots_CFGC!","text":"add_production_delivery_arcs_depots_CFGC!(fg::FlowGraph;\n                                            instance::Instance,\n                                            commodity_index::Int,\n)\n\nAdd the arcs corresponding to release and quantities to send to other customers.\n\nWe use the arcs from production to the morning of each day to set the release of each customer in accordance with the data stored in instance. Besides, since we fix a part of the solution when optimizing the reinsertion of  one customer, the arcs to delivery_other_customers nodes are used to take the  other deliveries into account in the inventory dynamics of the depots.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_routes_arcs_CFGC!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_routes_arcs_CFGC!","text":"add_routes_arcs_CFGC!(fg::FlowGraph;\n                        instance::Instance,\n                        customer_index::Int,\n                        commodity_index::Int, \n                        routes::Vector{Route},\n                        dates::Vector,\n                        costs::Vector,\n                        force_values::Bool,\n                        former_quantities_former_routes::Dict, \n                        former_quantities_new_routes::Array,\n)\n\nAdd the arcs corresponding to the routes paths.\n\nTwo types of routes are represented:\n\nnew direct ones from depots to the customer with customer_index.\nold routes with each possible position of the customer for reinsertion.   The (routing + other customers inventories and shortage) costs induced by    the reinsertion at each position are precomputed and stored in costs.   The dates of arrival at each reinsertion position are also precomputed    and stored in dates.\n\nWe enable forcing the quantities to send through the routes with the boolean force_values and quantities former_quantities_former_routes and  former_quantities_new_routes. This is done to initialize the flow solution with the value deduced from the current IRP solution, to speed-up computations. This is done in one_step_ruin_recreate_customer!.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.add_shortage_demand_arcs_customer_CFGC!-Tuple{InventoryRoutingLNS.FlowGraph}","page":"Flows and Graphs","title":"InventoryRoutingLNS.add_shortage_demand_arcs_customer_CFGC!","text":"add_shortage_demand_arcs_customer_CFGC!(fg::FlowGraph;\n                                        instance::Instance,\n                                        customer_index::Int,\n                                        commodity_index::Int,\n)\n\nAdd the arcs corresponding to demand and shortage.\n\nAs for the release, the arcs from each morning to the node demand are used to fix the demand in accordance with the data of instance. Besides, we create arcs from the node shortage_compensation to each morning  node with shortage cost to model the soft minimum inventory constraint. \n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.commodity_flow_graph_customer-Tuple{InventoryRoutingLNS.Instance}","page":"Flows and Graphs","title":"InventoryRoutingLNS.commodity_flow_graph_customer","text":"commodity_flow_graph_customer(instance::Instance;\n                                customer_index::Int,\n                                commodity_index::Int,\n                                routes::Vector{Route},\n                                dates::Vector,\n                                costs::Vector,\n                                force_values::Bool = false,\n                                former_quantities_former_routes::Dict = Dict(), \n                                former_quantities_new_routes::Array = zeros(1),\n)\n\nCreate the commodity flow graph corresponding to commodity_index for the reinsertion of  the customer with index customer_index.\n\nThe (routing + other customers inventories and shortage) costs induced by  the reinsertion at each position are precomputed and stored in costs. The dates of arrival at each reinsertion position are also precomputed  and stored in dates. We enable forcing the quantities to send through the routes with the boolean force_values and quantities former_quantities_former_routes and  former_quantities_new_routes. This is done to initialize the flow solution with the value deduced from the current IRP solution, to speed-up computations. This is done in one_step_ruin_recreate_customer!. The flowgraph is based on the structure FlowGraph.\n\n\n\n\n\n","category":"method"},{"location":"flows/#Vehicle-flow-graphs","page":"Flows and Graphs","title":"Vehicle flow graphs","text":"","category":"section"},{"location":"flows/","page":"Flows and Graphs","title":"Flows and Graphs","text":"Modules = [InventoryRoutingLNS]\nPages = [\"flows/truck_graph.jl\",\n\"flows/truck_graph_single_customer.jl\"]","category":"page"},{"location":"flows/#InventoryRoutingLNS.expanded_vehicle_flow_graph-Tuple{InventoryRoutingLNS.Instance}","page":"Flows and Graphs","title":"InventoryRoutingLNS.expanded_vehicle_flow_graph","text":"expanded_vehicle_flow_graph(instance::Instance; \n                                add_new_routes_arcs::Bool = true,\n                                S_max::Int, \n                                maxdist::Real = Inf,\n                                fixed_routes::Union{Nothing, Vector{Route}} = nothing,\n                                fixed_routes_costs::Union{Nothing, Vector{Int}} = nothing,\n)\n\nCreate a vehicles' flow graph with old fixed and new routes.\n\nThis function is called to derive the commodity reinsertion MILP in commodity_insertion_MILP as well as the MILP to refill  fixed routes in fill_fixed_routes_MILP.\n\nTwo types of routes are represented:\n\nnew direct ones from depots to customers, added when add_new_routes_arcs is true.   When creating new routes, the argument maxdist may be used to sparsify the graph    by removing arcs with long distances. The maximum length of new routes is defined    by S_max, which is possibly distinct from the value of instance.S_max.\nold fixed_routes that visit several stops, with corresponding costs fixed_routes_costs.\n\n\n\n\n\n","category":"method"},{"location":"flows/#InventoryRoutingLNS.expanded_vehicle_flow_graph_customer-Tuple{InventoryRoutingLNS.Instance}","page":"Flows and Graphs","title":"InventoryRoutingLNS.expanded_vehicle_flow_graph_customer","text":"expanded_vehicle_flow_graph_customer(instance::Instance;\n                                        customer_index::Int,\n                                        routes::Vector{Route},\n                                        cost_per_route::Vector,\n                                        dates::Vector,\n)\n\nCreate the vehicles' flow graph of a customer indexed by customer_index.\n\nThis function is called to derive the customer reinsertion MILP in customer_insertion_flow.\n\nTwo types of routes are represented:\n\nnew direct ones from depots to the customer with customer_index.\nold routes with each possible position of the customer for reinsertion.   The (routing + other customers inventories and shortage) costs induced by    the reinsertion at each position are precomputed and stored in cost_per_route.   The dates of arrival at each reinsertion position are also precomputed    and stored in dates.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#Heuristics","page":"Heuristics","title":"Heuristics","text":"","category":"section"},{"location":"heuristics/#Bin-packing","page":"Heuristics","title":"Bin packing","text":"","category":"section"},{"location":"heuristics/","page":"Heuristics","title":"Heuristics","text":"Modules = [InventoryRoutingLNS]\nPages = [\"heuristics/bin_packing.jl\"]","category":"page"},{"location":"heuristics/#InventoryRoutingLNS.bin_packing_milp-Union{Tuple{IT}, Tuple{Vector{IT}, Vector{<:Real}, Real}} where IT","page":"Heuristics","title":"InventoryRoutingLNS.bin_packing_milp","text":"bin_packing_milp(items::Vector{IT}, weights::Vector{<:Real}, W::Real) where {IT}\n\nApply exact bin-packing to (items, weights) within a container of capacity W.\n\nSolve a MILP.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.first_fit_decreasing-Union{Tuple{IT}, Tuple{Vector{IT}, Vector{<:Real}, Real}} where IT","page":"Heuristics","title":"InventoryRoutingLNS.first_fit_decreasing","text":"first_fit_decreasing(items::Vector{IT},\n                        weights::Vector{<:Real},\n                        W::Real,\n) where {IT}\n\nApply FFD bin-packing to (items, weights) within a container of capacity W.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#Delays-from-instance","page":"Heuristics","title":"Delays from instance","text":"","category":"section"},{"location":"heuristics/","page":"Heuristics","title":"Heuristics","text":"Modules = [InventoryRoutingLNS]\nPages = [\"heuristics/delays_from_instance.jl\"]","category":"page"},{"location":"heuristics/#InventoryRoutingLNS.compute_delays-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.compute_delays","text":"compute_delays(instance::Instance)\n\nGiven instance, we compute the possible delays for each depot-customer couple.\n\nThe possible delays are induced by indirect routes.  This information is used to build commodity graphs with  commodity_flow_graph to compute a relaxation in lower_bound.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#Greedy-heuristic","page":"Heuristics","title":"Greedy heuristic","text":"","category":"section"},{"location":"heuristics/","page":"Heuristics","title":"Heuristics","text":"Modules = [InventoryRoutingLNS]\nPages = [\"heuristics/greedy_heuristic.jl\"]","category":"page"},{"location":"heuristics/#InventoryRoutingLNS.fill_trucks!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.fill_trucks!","text":"fill_trucks!(instance::Instance; sent_quantities::Array{Int,4})\n\nUpdate instance with new routes deduced from a bin packing based on sent_quantities.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.initialization_plus_ls!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.initialization_plus_ls!","text":"initialization_plus_ls!(instance::Instance;\n                    maxdist::Real = Inf,\n                    average_content_sizes::Union{Nothing,AverageContentSizes} = nothing,\n                    verbose::Bool = true,\n                    reset_after::Bool = false,\n                    stats::Union{Nothing, Dict} = nothing,\n                    sent_quantities::Union{Nothing, Array{Int,4}} = nothing,\n)\n\nApply a flow initialization followed by a single-depot localsearch to instance.\n\nWe first choose the quantities to send with the flow problem, initialize the IRP  solution with iterative bin packin problems, and then improve the solution with  single-depot moves.\n\nThe maxdist argument is used to sparsify graphs based on distances, see commodity_flow_graph for the details.\n\nThe average_content_sizes data is used when using statistics of a former pass to  re-estimate the routing arc costs on the commodity flow graphs.  See modified_capa_initialization_plus_ls! for the details of this process.\n\nThe reset_after boolean is to decide to reset the instance solution after  this greedy_heuristic or not. \n\nInstead of using the flows to initialize the quantities to send, we can use  the sent_quantities values. This is done to show that the flows decoded from  the LNS! solution are good solutions to the IRP when decoded by this function.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.modified_capa_initialization_plus_ls!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.modified_capa_initialization_plus_ls!","text":"modified_capa_initialization_plus_ls!(instance::Instance;\n                                maxdist::Real = Inf,\n                                verbose::Bool = true,\n                                stats::Dict = nothing,\n)\n\nApply initialization_plus_ls! two times and update costs from statistics of the first pass.\n\nThe maxdist argument is used to sparsify graphs based on distances, see commodity_flow_graph for the details.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#Relaxation","page":"Heuristics","title":"Relaxation","text":"","category":"section"},{"location":"heuristics/","page":"Heuristics","title":"Heuristics","text":"Modules = [InventoryRoutingLNS]\nPages = [\"heuristics/relaxation.jl\"]","category":"page"},{"location":"heuristics/#InventoryRoutingLNS.lower_bound-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.lower_bound","text":"lower_bound(instance::Instance)\n\nDefine and solve the initial flow relaxation problem on instance.\n\nThis relaxation implies the computation of possible delays  to create direct delayed arcs in the commodity flow graphs. See compute_delays for the delay computation,  and commodity_flow_graphfor the impact on the commodity graphs.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.solve_flows_initial_solution-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.solve_flows_initial_solution","text":"solve_flows_initial_solution(instance::Instance; average_content_sizes::Union{Nothing,AverageContentSizes} = nothing)\n\nDefine and solve the initial flow problems to decide the quantities to send.\n\nFrom the quantities we solve bin packing problems  and apply localsearch in  initialization_plus_ls!.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#Refill-routes-with-fixed-path","page":"Heuristics","title":"Refill routes with fixed path","text":"","category":"section"},{"location":"heuristics/","page":"Heuristics","title":"Heuristics","text":"Modules = [InventoryRoutingLNS]\nPages = [\"heuristics/fill_fixed_routes.jl\"]","category":"page"},{"location":"heuristics/#InventoryRoutingLNS.decode_MILP_solution!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.decode_MILP_solution!","text":"decode_MILP_solution!(instance::Instance;\n                        fixed_routes::Vector{Route},\n                        flow_commodities::Matrix{Int},\n                        fgs_commodities::Vector{FlowGraph},\n)\n\nGiven the solution of the MILP in fill_fixed_routes_MILP, fill fixed_routes.\n\nWe use fgs_commodities to link the flow_commodities variables indices with the  corresponding routes to fill in fixed_routes.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.fill_fixed_routes_MILP-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.fill_fixed_routes_MILP","text":"fill_fixed_routes_MILP(instance::Instance;\n                        fixed_routes::Vector{Route},\n                        fixed_routes_costs::Vector{Int},\n                        integer::Bool = true,\n                        verbose::Bool = true,\n                        refill_neighborhood::Bool = false,\n                        force_quantities::Bool = false,\n                        use_warm_start::Bool = false,\n                        values_commodity_flows::Matrix{Int}\n)\n\nGiven a set of fixed_routes, use them or not, and fill the used-ones with commodities.\n\nWhen solved to optimality, this MILP is the exact decision problem of optimizing the  use and deliveries inherent in a set of routes (paths). The boolean force_quantities is used to solve a degenerate MILP with sent quantities set  to the previous values. It is used to provide a first solution as values_commodity_flows to  a second call of this function with use_warm_start set to true, to solve the MILP with a warm start.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.refill_every_route!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.refill_every_route!","text":"refill_every_route!(instance::Instance; verbose::Bool = false)\n\nRefill all the routes of a solution at once.\n\nIn this case we use refill_routes! on the whole set  of routes in the current solution of instance.\n\nWe emphasize that this exact MILP may be too large to  solve in practice for big IRP instances. We thus suggest some ways to  fix a part of the solution and use it as large neighborhood.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.refill_iterative_commodity_reinsertion!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.refill_iterative_commodity_reinsertion!","text":"refill_iterative_commodity_reinsertion!(instance::Instance; \n                                        stats::Union{Nothing, Dict} = nothing, \n                                        verbose::Bool = false\n)\n\nApply one_step_ruin_recreate_commodity! commodity-by-commodity.\n\nContrary to refill_every_route!, this iterative way of  refilling every route of a solution can be used on large instances.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.refill_iterative_days!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.refill_iterative_days!","text":"refill_iterative_days!(instance::Instance; \n                        verbose::Bool = false, \n                        stats::Union{Dict, Nothing} = nothing\n)\n\nApply refill_routes_on_day! day-by-day.\n\nContrary to refill_every_route!, this iterative way of  refilling every route of a solution can be used on large instances.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.refill_iterative_depot!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.refill_iterative_depot!","text":"refill_iterative_depot!(instance::Instance; \n                        verbose::Bool = false, \n                        stats::Union{Dict, Nothing} = nothing\n)\n\nApply refill_routes_from_depot! depot-by-depot.\n\nContrary to refill_every_route!, this iterative way of  refilling every route of a solution can be used on large instances.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.refill_routes!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.refill_routes!","text":"refill_routes!(instance::Instance; \n                    fixed_routes::Vector{Route}, \n                    fixed_routes_costs::Vector{Int}, \n                    verbose::Bool = false,\n                    refill_neighborhood::Bool = false,\n                    stats::Union{Dict, Nothing} = nothing,\n)\n\nGiven a set of routes, empty them, solve the refill MILP and decode the solution.\n\nThe routes to consider and corresponding costs are stored in fixed_routes and fixed_routes_costs respectively. It can be used in a large neighborhood, which entails fixing a part of the solution and creating special nodes and arcs in the  commodity flow graphs (see commodity_flow_graph),  indicated by the boolean refill_neighborhood.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.refill_routes_from_depot!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.refill_routes_from_depot!","text":"refill_routes_from_depot!(instance::Instance; \n                            depot_index::Int, \n                            verbose::Bool = false, \n                            stats::Union{Dict, Nothing} = nothing\n)\n\nRefill all the routes that start from a given depot indexed by depot_index.\n\nIn this case we use refill_routes! as a large neighborhood.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#InventoryRoutingLNS.refill_routes_on_day!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.refill_routes_on_day!","text":"refill_routes_on_day!(instance::Instance; \n                        t::Int, \n                        verbose::Bool = false, \n                        stats::Union{Dict, Nothing} = nothing\n)\n\nRefill all the routes that start on a given day t.\n\nIn this case we use refill_routes! as a large neighborhood.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#Matheuristic","page":"Heuristics","title":"Matheuristic","text":"","category":"section"},{"location":"heuristics/","page":"Heuristics","title":"Heuristics","text":"Modules = [InventoryRoutingLNS]\nPages = [\"heuristics/matheuristic.jl\"]","category":"page"},{"location":"heuristics/#InventoryRoutingLNS.paper_matheuristic!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.paper_matheuristic!","text":"paper_matheuristic!(instance::Instance;\n                n_it_commodity_reinsertion::Int,\n                n_it_customer_reinsertion::Int, \n                tol::Float64 = 0.01,\n                time_limit::Float64 = 90.0,\n                verbose::Bool = false,\n)\n\nSolve the instance instance with a matheuristic;\n\nThe matheuristic consists in:\n\ntwo passes of the greedy heuristic, see modified_capa_initialization_plus_ls!.\none Large Neighborhood Search defined in LNS!.\n\nThe number of commodity reinsertion per LNS iteration is n_it_commodity_reinsertion, same for n_it_customer_reinsertion and customer reinsertion. We can set a time limit  to the solution process with time_limit.\n\n\n\n\n\n","category":"method"},{"location":"heuristics/#Benchmark","page":"Heuristics","title":"Benchmark","text":"","category":"section"},{"location":"heuristics/","page":"Heuristics","title":"Heuristics","text":"Modules = [InventoryRoutingLNS]\nPages = [\"heuristics/benchmark_heuristic.jl\"]","category":"page"},{"location":"heuristics/#InventoryRoutingLNS.route_based_matheuristic!-Tuple{InventoryRoutingLNS.Instance}","page":"Heuristics","title":"InventoryRoutingLNS.route_based_matheuristic!","text":"route_based_matheuristic!(instance::Instance;\n                        time_limit::Float64,\n                        verbose::Bool = true, \n)\n\nAdapt the ideas of recent papers such as A matheuristic algorithm for the multi-depot inventory routing problem and A Matheuristic for the Multivehicle Inventory Routing Problem to solve the multi-attribute IRP.\n\nThe benchmark works as follows:\n\nFirst create an initial solution with the modified_capa_initialization_plus_ls! (flows + localsearch)\nThen iteratively solve MILPS with refill_iterative_depot! to exploit the routes of the initial solution.\n\nIn the original papers one MILP is solved on a larger set of routes and all  considered at once. Here because of the size of the instances and additional  structure (multi-depot, multi-commodity, routes that last several days) we  adapt the ideas solving one MILP per depot (heuristic).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#Large-neighborhood-search","page":"Large Neighborhood Search","title":"Large neighborhood search","text":"","category":"section"},{"location":"localsearch/#Small-neighborhoods","page":"Large Neighborhood Search","title":"Small neighborhoods","text":"","category":"section"},{"location":"localsearch/#TSP-generalized","page":"Large Neighborhood Search","title":"TSP generalized","text":"","category":"section"},{"location":"localsearch/","page":"Large Neighborhood Search","title":"Large Neighborhood Search","text":"Modules = [InventoryRoutingLNS]\nPages = [\"local_search/TSP_neighborhoods.jl\",\n\"local_search/route_single_optim.jl\",\n\"local_search/route_delete.jl\"]","category":"page"},{"location":"localsearch/#InventoryRoutingLNS.TSP_neighborhood!-Tuple{}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.TSP_neighborhood!","text":"TSP_neighborhood!(;route::Route, \n                    instance::Instance, \n                    neighborhood_index::Int, \n                    index_1::Int, \n                    index_2::Int, \n                    stats::Dict, \n                    in_LNS::Bool\n)\n\nApply one of the three following TSP neighborhoods to route: relocate, swap, 2-opt*.\n\nEach neighborhood involves two indices index_1 and index_2. We use neighborhood_index  to choose to apply relocate (1), swap (2) or two_opt_star (3). The in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.iterative_TSP_neighborhood!-Tuple{}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_TSP_neighborhood!","text":"iterative_TSP_neighborhood!(;route::Route, \n                            instance::Instance, \n                            neighborhood_index::Int, \n                            stats::Dict, \n                            in_LNS::Bool\n)\n\nIteratively apply a TSP neighborhood to the stops of route untill no improvement.\n\nWe use neighborhood_index to choose to apply relocate (1), swap (2) or two_opt_star (3). The in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.compress!-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.compress!","text":"compress!(route::Route, instance::Instance)\n\nMerge stops that visit the same customer, all gathered at the first date of stop.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.compute_optimized_route_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.compute_optimized_route_cost","text":"compute_optimized_route_cost(route::Route, instance::Instance)\n\nCompute the cost of an optimally compressed and reordered copy of route.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.optimize_route!-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.optimize_route!","text":"optimize_route!(route::Route, instance::Instance)\n\nCompress and reorder route to optimality.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.optimize_route-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.optimize_route","text":"optimize_route(route::Route, instance::Instance)\n\nCompress and reorder a copy of route to optimality.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.reorder_optimally!-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.reorder_optimally!","text":"reorder_optimally!(route::Route, instance::Instance)\n\nFind optimal stops' order and apply it to route.\n\nBrutal enumeration of the possible permutations.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.update_route_order!-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance, Vector{Int64}}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.update_route_order!","text":"update_route_order!(route::Route, instance::Instance, perm::Vector{Int})\n\nUpdate a route from a permutation perm of its stops.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.delete_non_profitable_routes!","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.delete_non_profitable_routes!","text":"delete_non_profitable_routes!(instance::Instance,\n                                verbose::Bool = false;\n                                stats::Dict = nothing,\n                                 in_LNS::Bool = true,\n)\n\nApply delete_non_profitable_routes! every day.\n\n\n\n\n\n","category":"function"},{"location":"localsearch/#InventoryRoutingLNS.delete_non_profitable_routes!-Tuple{InventoryRoutingLNS.Instance, Int64, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.delete_non_profitable_routes!","text":"delete_non_profitable_routes!(instance::Instance, \n                                t::Int, \n                                d::Int\n)\n\nDelete routes starting on day t by depot d when the total cost decreases.\n\nNot used in the current version.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.delete_non_profitable_routes!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.delete_non_profitable_routes!","text":"delete_non_profitable_routes!(instance::Instance,\n                                t::Int;\n                                stats::Dict = nothing,\n                                in_LNS::Bool = true,\n)\n\nDelete routes starting on day t when the total cost decreases.\n\nThe in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#Single-depot-SDVRP-generalized","page":"Large Neighborhood Search","title":"Single-depot SDVRP generalized","text":"","category":"section"},{"location":"localsearch/","page":"Large Neighborhood Search","title":"Large Neighborhood Search","text":"Modules = [InventoryRoutingLNS]\nPages = [\"local_search/neighborhood_pruning.jl\",\n\"local_search/route_exchange.jl\",\n\"local_search/route_merge_multiday.jl\",\n\"local_search/route_merge.jl\"]","category":"page"},{"location":"localsearch/#InventoryRoutingLNS.get_neighbors_from_list-Tuple{InventoryRoutingLNS.Instance, Int64, Vector{Int64}, Float64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.get_neighbors_from_list","text":"get_neighbors_from_list(instance::Instance,\n                        c::Int,\n                        cs::Vector{Int},\n                        prop::Float64,\n)::Vector{Int}\n\nSelect the prop proportion of the closest neighbors to a customer c among customers cs.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.insert_single_depot!-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Route, Int64, InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.insert_single_depot!","text":"insert_single_depot!(route1::Route,\n                        route2::Route,\n                        i::Int,\n                        instance::Instance;\n                        stats::Dict = nothing,\n                        in_LNS::Bool = true,\n)\n\nPush route1.stops[i] to route2.stops and apply compress! to avoid stop repetition.\n\nOnly applied on routes with same dates of departure and same starting depot. The in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.insert_swap_single_depot_routes!","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.insert_swap_single_depot_routes!","text":"insert_swap_single_depot_routes!(instance::Instance,\n                                    verbose::Bool = false;\n                                    stats::Dict = nothing,\n                                    in_LNS::Bool = true,\n)\n\nApply iterative_insert_single_depot! and iterative_swap_single_depot! on every day, depot config.\n\nThe in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"function"},{"location":"localsearch/#InventoryRoutingLNS.iterative_insert_single_depot!-Tuple{InventoryRoutingLNS.Instance, Int64, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_insert_single_depot!","text":"iterative_insert_single_depot!(instance::Instance,\n                                t::Int,\n                                d::Int;\n                                stats::Dict = nothing,\n                                in_LNS::Bool = true,\n)\n\nTry insert_single_depot! on pairs of routes sampled on day t starting at depot d.\n\nThe in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.iterative_swap_single_depot!-Tuple{InventoryRoutingLNS.Instance, Int64, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_swap_single_depot!","text":"iterative_swap_single_depot!(instance::Instance,\n                                t::Int,\n                                d::Int;\n                                stats::Dict = nothing,\n                                in_LNS::Bool = true,\n)\n\nTry swap_single_depot! on pairs of routes sampled on day t starting at depot d.\n\nThe in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.swap_single_depot!-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Route, Int64, Int64, InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.swap_single_depot!","text":"swap_single_depot!(route1::Route,\n                    route2::Route,\n                    i::Int,\n                    j::Int,\n                    instance::Instance;\n                    stats::Dict = nothing,\n                    in_LNS::Bool = true,\n)\n\nExchange route1.stops[i] and route2.stops[j] and apply compress! to avoid stop repetition.\n\nOnly applied on routes with same dates of departure and same starting depot. The in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.concatenate_multiday-Tuple{Vector{InventoryRoutingLNS.Route}}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.concatenate_multiday","text":"concatenate_multiday(routes::Vector{Route})::Route\n\nConcatenate routes that share the same depot, shifting them all to the earliest day.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.find_best_merge_multiday-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.find_best_merge_multiday","text":"find_best_merge_multiday(instance::Instance, \n                            d::Int\n)\n\nFind the best pair of routes (related to the same depot d) to merge based on cost gain.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.gain_merge_multiday-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.gain_merge_multiday","text":"gain_merge_multiday(route1::Route, \n                    route2::Route, \n                    instance::Instance\n)::Float64\n\nCompute the cost gain of merging two routes.\n\nInf if infeasible.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.iterative_merge_multiday!","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_merge_multiday!","text":"iterative_merge_multiday!(instance::Instance,\n                            verbose::Bool = false;\n                            stats::Dict = nothing,\n                            in_LNS::Bool = true,\n)\n\nApply perform_best_merge_multiday! on every depot until no improvement found.\n\nThe in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"function"},{"location":"localsearch/#InventoryRoutingLNS.iterative_merge_multiday!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_merge_multiday!","text":"iterative_merge_multiday!(instance::Instance,\n                            d::Int;\n                            stats::Dict = nothing,\n                            in_LNS::Bool = true,\n)\n\nApply perform_best_merge_multiday! on depot d until no improvement found.\n\nThe in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.perform_best_merge_multiday!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.perform_best_merge_multiday!","text":"perform_best_merge_multiday!(instance::Instance,\n                                d::Int;\n                                stats::Dict = nothing,\n                                in_LNS::Bool = true,\n)\n\nPerform the best merge over the routes related to the same depot d.\n\nThe in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.concatenate-Tuple{Vector{InventoryRoutingLNS.Route}}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.concatenate","text":"concatenate(routes::Vector{Route})\n\nConcatenate routes that share the same depot and departure date.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.evaluate_all_merges-Tuple{InventoryRoutingLNS.Instance, Int64, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.evaluate_all_merges","text":"evaluate_all_merges(instance::Instance, \n                    t::Int, \n                    d::Int\n)\n\nEvaluate all the possible merges related to d and t in the current solution.\n\nInf if infeasible.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.gain_merge-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.gain_merge","text":"gain_merge(route1::Route, \n            route2::Route, \n            instance::Instance\n)::Float64\n\nCompute the cost gain of merging two routes having same starting depot and day.\n\nInf if infeasible.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.iterative_merge!","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_merge!","text":"iterative_merge!(instance::Instance,\n                    verbose::Bool = false;\n                    stats::Dict = nothing,\n                    in_LNS::Bool = true,\n)\n\nApply perform_best_merge! on every depot and day until no improvement found.\n\nThe in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"function"},{"location":"localsearch/#InventoryRoutingLNS.iterative_merge!-Tuple{InventoryRoutingLNS.Instance, Int64, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_merge!","text":"iterative_merge!(instance::Instance,\n                    t::Int,\n                    d::Int;\n                    stats::Dict = nothing,\n                    in_LNS::Bool = true,\n)\n\nApply perform_best_merge! on depot d and day t until no improvement found.\n\nThe in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.perform_best_merge!-Tuple{InventoryRoutingLNS.Instance, Int64, Int64, Matrix{Float64}}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.perform_best_merge!","text":"perform_best_merge!(instance::Instance,\n                    t::Int,\n                    d::Int,\n                    ::Matrix{Float64};\n                    stats::Dict = nothing,\n                    in_LNS::Bool = true,\n)\n\nPerform the best merge over the routes related to the same depot d and departure date t.\n\nIn  we store the gain of merge for each pair of routes, iteratively updated. The in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#Multi-depot-SDVRP-generalized","page":"Large Neighborhood Search","title":"Multi-depot SDVRP generalized","text":"","category":"section"},{"location":"localsearch/","page":"Large Neighborhood Search","title":"Large Neighborhood Search","text":"Modules = [InventoryRoutingLNS]\nPages = [\"local_search/IRP_multiday_neighborhoods.jl\",\n\"local_search/IRP_neighborhoods.jl\"]","category":"page"},{"location":"localsearch/#InventoryRoutingLNS.change_day!-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.Route, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.change_day!","text":"change_day!(instance::Instance, \n            route::Route, \n            new_t::Int; \n            stats::Dict = nothing\n)\n\nChange the departure day of route to new_t.\n\nOnly possible one day in the past or in the future. Feasible if the last day of arrival is before the horizon T  and if the route depot has nonnegative inventory when moving to the past.  Applied if feasible and cost is reduced.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.change_day_all_one_pass!","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.change_day_all_one_pass!","text":"change_day_all_one_pass!(instance::Instance,\n                            direction::String = \"ahead\";\n                            stats::Dict = nothing,\n)\n\nTest change_day! on every route of the solution.\n\nThe direction can either be \"ahead\", \"back\" or \"random\". When random, we observe the realization of a Bernoulli random  variable with parameter p = 0.5 and move ahead or back.\n\n\n\n\n\n","category":"function"},{"location":"localsearch/#InventoryRoutingLNS.iterative_change_day!","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_change_day!","text":"iterative_change_day!(instance::Instance, \n                        direction::String = \"ahead\"; \n                        stats::Dict = nothing\n)\n\nApply change_day_all_one_pass! until no improvement is found.\n\n\n\n\n\n","category":"function"},{"location":"localsearch/#InventoryRoutingLNS.insert_multi_depot!-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.Route, InventoryRoutingLNS.Route, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.insert_multi_depot!","text":"insert_multi_depot!(instance::Instance,\n                    route1::Route,\n                    route2::Route,\n                    i::Int;\n                    stats::Dict = nothing,\n)\n\nPush route1.stops[i] to route2.stops and apply compress! to avoid stop repetition.\n\nOnly applied on routes with same dates of departure.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.insert_swap_multi_depot_per_day!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.insert_swap_multi_depot_per_day!","text":"insert_swap_multi_depot_per_day!(instance::Instance; \n                                    stats::Dict = nothing\n)\n\nApply iterative_insert_multi_depot! and iterative_swap_multi_depot! every day.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.iterative_insert_multi_depot!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_insert_multi_depot!","text":"iterative_insert_multi_depot!(instance::Instance, \n                                t::Int; \n                                stats::Dict = nothing\n)\n\nTry insert_multi_depot! on pairs of routes sampled on day t.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.iterative_swap_multi_depot!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_swap_multi_depot!","text":"iterative_swap_multi_depot!(instance::Instance, \n                            t::Int; \n                            stats::Dict = nothing\n)\n\nTry swap_multi_depot! on pairs of routes sampled on day t.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.iterative_two_opt_star_multi_depot!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_two_opt_star_multi_depot!","text":"iterative_two_opt_star_multi_depot!(instance::Instance, \n                                    t::Int; \n                                    stats::Dict = nothing\n)\n\nTry two_opt_star_multi_depot! on pairs of routes sampled on day t.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.swap_multi_depot!-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.Route, InventoryRoutingLNS.Route, Int64, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.swap_multi_depot!","text":"swap_multi_depot!(instance::Instance,\n                    route1::Route,\n                    route2::Route,\n                    i::Int,\n                    j::Int;\n                    stats::Dict = nothing,\n)\n\nExchange route1.stops[i] and route2.stops[j] and apply compress! to avoid stop repetition.\n\nOnly applied on routes with same dates of departure.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.two_opt_star_multi_depot!-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.Route, InventoryRoutingLNS.Route, Int64, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.two_opt_star_multi_depot!","text":"two_opt_star_multi_depot!(instance::Instance,\n                            route1::Route,\n                            route2::Route,\n                            k::Int,\n                            l::Int;\n                            stats::Dict = nothing,\n)\n\nExchange route1.stops[k+1:end] with route2.stops[l+1:end] and compress.\n\nOnly applied on routes with same dates of departure.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.two_opt_star_multi_depot_per_day!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.two_opt_star_multi_depot_per_day!","text":"two_opt_star_multi_depot_per_day!(instance::Instance; \n                                    stats::Dict = nothing\n)\n\nApply iterative_two_opt_star_multi_depot! every day.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#Large-neighborhoods","page":"Large Neighborhood Search","title":"Large neighborhoods","text":"","category":"section"},{"location":"localsearch/#Customer-reinsertion","page":"Large Neighborhood Search","title":"Customer reinsertion","text":"","category":"section"},{"location":"localsearch/","page":"Large Neighborhood Search","title":"Large Neighborhood Search","text":"Modules = [InventoryRoutingLNS]\nPages = [\"local_search/ruin_recreate_customer.jl\"]","category":"page"},{"location":"localsearch/#InventoryRoutingLNS.build_model_objective_customer_insertion_flow!-Tuple{JuMP.Model, InventoryRoutingLNS.FlowGraph, Vector{InventoryRoutingLNS.FlowGraph}, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.build_model_objective_customer_insertion_flow!","text":"build_model_objective_customer_insertion_flow!(model::JuMP.Model,\n                                                fg_vehicles::FlowGraph,\n                                                fgs_commodities::Vector{FlowGraph},\n                                                nb_m::Int,\n)\n\nDefine the objective function of the customer insertion MILP based on vehicles' and commodities' flow variables.\n\nThis cost is the sum of:\n\none vehicles' flow cost given the arcs' costs of the fg_vehicles graph.\none commodity cost per commodity given fgs_commodities arcs costs.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.coupling_constraint_customer_flow_insertion!-Tuple{JuMP.Model, InventoryRoutingLNS.Instance, Int64, Vector{Any}, Int64, Vector{InventoryRoutingLNS.FlowGraph}, InventoryRoutingLNS.FlowGraph, Vector{InventoryRoutingLNS.Route}, Vector{Float64}, Vector, Vector}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.coupling_constraint_customer_flow_insertion!","text":"coupling_constraint_customer_flow_insertion!(model::JuMP.Model,\n                                                instance::Instance,\n                                                customer_index::Int,\n                                                indices_m::Vector{Any},\n                                                nb_m::Int,\n                                                fgs_commodities::Vector{FlowGraph},\n                                                fg_vehicles::FlowGraph,\n                                                old_possible_routes::Vector{Route},\n                                                places::Vector{Float64},\n                                                costs::Vector,\n                                                dates::Vector,\n)\n\nAdd the constraints binding commodities and vehicles variables related to the reinsertion of customer customer_index.\n\nThose bindings occur for two types of routes:\n\nnew direct routes (relaxation of the capacity constraints per vehicle at the arc level).\nold routes in the solution (exact constraints given the pre-computed data).\n\nIn both cases we focus on a subset of nb_m commodities indexed by indices_m \n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.customer_insertion_flow-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.customer_insertion_flow","text":"customer_insertion_flow(instance::Instance;\n                        customer_index::Int,\n                        old_possible_routes::Vector{Route},\n                        costs::Vector,\n                        places::Vector,\n                        dates::Vector,\n                        former_quantities_former_routes::Dict, \n                        former_quantities_new_routes::Array,\n                        use_warm_start::Bool,\n                        force_values::Bool,\n                        values_vehicles_flow::Array,\n                        values_commodities_flows::Array,\n)\n\nDefine and solve the customer insertion MILP for the customer indexed by customer_index.\n\nWe possibly force the values on former and new routes using force_values  boolean and former_quantities_former_routes and former_quantities_new_routes  information, see commodity_flow_graph_customer.\n\nWe can use a warmstart if use_warm_start is true, with the values of the flows set  to values_commodities_flows and values_vehicles_flow.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.fill_former_routes_customer_insertion!-Tuple{InventoryRoutingLNS.Instance, Vector{InventoryRoutingLNS.Route}, Array{Int64}, Array, InventoryRoutingLNS.FlowGraph, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.fill_former_routes_customer_insertion!","text":"fill_former_routes_customer_insertion!(instance::Instance,\n                                        old_possible_routes::Vector{Route},\n                                        flows::Array{Int},\n                                        commodities_of_c::Array,\n                                        fg_commodity::FlowGraph,\n                                        customer_index::Int,\n)\n\nDeduce from the flow variables the former routes to modify to deliver the customer indexed by customer_index.\n\nThe routes to fill are the old_possible_routes. We use the graph structure  of fg_commodity to make a link between the routes' insertion positions and the indices of flows variable.  We highlight the commodity flow graphs share the same arcs, thus one reference graph is usefull. \n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.fill_new_routes_customer_insertion!-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.FlowGraph, Array, Vector, Int64, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.fill_new_routes_customer_insertion!","text":"fill_new_routes_customer_insertion!(instance::Instance,\n                                    fg_commodity::FlowGraph,\n                                    flows::Array,\n                                    indices_m::Vector,\n                                    nb_m::Int,\n                                    customer_index::Int,\n)\n\nCreate new routes solving bin packing problems involving quantities of flows.\n\nWe use the graph structure of fg_commodity to make a link between  the routes to create and the indices of flows variable. Only new direct routes are created since one customer is involved.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.location_and_cost_insertion!-Tuple{InventoryRoutingLNS.Instance, Int64, Vector{InventoryRoutingLNS.Route}}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.location_and_cost_insertion!","text":"location_and_cost_insertion!(instance::Instance, c::Int, routes::Vector{Route})\n\nCompute the costs, dates and capacities corresponding to the insertion places of customer c in routes.\n\nFor each route we compute and save the remaining loading capacity in places,  the cost induced by the reinsertion of customer c (other customers' inventory and shortage costs induced by delays, and routing costs) at each position in  costs, and the dates of arrival to the corresponding reinsertion positions  in dates. This information is used to build both the commodities and vehicles  flow graphs, see commodity_flow_graph_customer and expanded_vehicle_flow_graph_customer.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.one_step_ruin_recreate_customer!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.one_step_ruin_recreate_customer!","text":"one_step_ruin_recreate_customer!(instance::Instance, customer_index::Int)\n\nRemove and insert the customer indexed by customer_index in the current solution.\n\nWe first remove the customer with remove_customer!, then precompute costs, dates and remaining capacities with location_and_cost_insertion!, solve the reinsertion  MILP with customer_insertion_flow, then fill former and new routes with  fill_former_routes_customer_insertion! and fill_new_routes_customer_insertion! respectively.  A warmstart is performed to gain speed, initialized at the last solution.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.remove_customer!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.remove_customer!","text":"remove_customer!(instance::Instance, c::Int)\n\nRemove the customer indexed by c from the routes of the solution.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#Commodity-reinsertion","page":"Large Neighborhood Search","title":"Commodity reinsertion","text":"","category":"section"},{"location":"localsearch/","page":"Large Neighborhood Search","title":"Large Neighborhood Search","text":"Modules = [InventoryRoutingLNS]\nPages = [\"local_search/ruin_recreate_commodity.jl\"]","category":"page"},{"location":"localsearch/#InventoryRoutingLNS.commodity_insertion_MILP-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.commodity_insertion_MILP","text":"commodity_insertion_MILP(instance::Instance;\n                            commodity_index::Int,\n                            integer::Bool,\n                            maxdist::Real,\n                            former_quantities_former_routes::Dict,\n                            former_quantities_new_routes::Array,\n                            force_values::Bool,\n                            values_vehicles_flow::Array,\n                            values_commodities_flows::Array,\n                            use_warm_start::Bool\n)\n\nDefine and solve the MILP for the reinsertion of commodity indexed by commodity_index.\n\nWe choose integer variables with the boolean integer.\n\nWe possibly sparsify the graphs with maxdist, and force the values on  former and new routes using force_values boolean and former_quantities_former_routes and former_quantities_new_routes information, see commodity_flow_graph.\n\nWe can use a warmstart if use_warm_start is true, with the values of the flows set  to values_commodities_flows and values_vehicles_flow.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.fill_former_routes_commodity_insertion!-Tuple{InventoryRoutingLNS.Instance, Vector{Int64}, Vector{Int64}, InventoryRoutingLNS.FlowGraph, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.fill_former_routes_commodity_insertion!","text":"fill_former_routes_commodity_insertion!(instance::Instance,\n                                        old_possible_routes_indices::Vector{Int},\n                                        flow_commodity::Vector{Int},\n                                        fg_commodity::FlowGraph,\n                                        commodity_index::Int,\n)\n\nFill the former routes with commodity commodity_index reading the flow variables.\n\nThe routes to fill are indexed by old_possible_routes_indices. We use the graph structure of fg_commodity to make a link between  the routes and the indices of the flow_commodity Vector.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.fill_new_routes_commodity_insertion!-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.FlowGraph, Vector{Int64}, Int64}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.fill_new_routes_commodity_insertion!","text":"fill_new_routes_commodity_insertion!(instance::Instance,\n                                        fg_commodity::FlowGraph,\n                                        flow_commodity::Vector{Int},\n                                        commodity_index::Int,\n)\n\nCreate new routes solving bin packing problems involving the flow flow_commodity.\n\nWe use the graph structure of fg_commodity to make a link between  the routes to create and the indices of the flow_commodity Vector. We restrict those new routes to be direct.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.one_step_ruin_recreate_commodity!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.one_step_ruin_recreate_commodity!","text":"one_step_ruin_recreate_commodity!(instance::Instance;\n                                    commodity_index::Int,\n                                    integer::Bool,\n                                    maxdist::Real,\n                                    delete_empty_routes::Bool = true,\n)\n\nRemove and insert the commodity indexed by commodity_index in the current solution.\n\nWe first remove the commodity with remove_commodity!, then solve the reinsertion  MILP with commodity_insertion_MILP, then fill former and new routes with  fill_former_routes_commodity_insertion! and fill_new_routes_commodity_insertion! respectively.  A warmstart is performed to gain speed, initialized at the last solution.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.remove_commodity!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.remove_commodity!","text":"remove_commodity!(instance::Instance; \n                    commodity_index::Int, \n                    delete_empty_routes::Bool = true\n)\n\nRemove the commodity indexed by commodity_index from the routes of the solution.\n\nWe update the instance solution depending on delete_empty_routes. If true, the routes with empty vehicles are deleted from the solution. Else, they are kept.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#Algorithms-for-exploration","page":"Large Neighborhood Search","title":"Algorithms for exploration","text":"","category":"section"},{"location":"localsearch/","page":"Large Neighborhood Search","title":"Large Neighborhood Search","text":"Modules = [InventoryRoutingLNS]\nPages = [\"local_search/local_search.jl\"]","category":"page"},{"location":"localsearch/#InventoryRoutingLNS.LNS!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.LNS!","text":"LNS!(instance::Instance;\n        tol::Real = 0.01,\n        n_it_commodity_reinsertion::Int,\n        n_it_customer_reinsertion::Int,\n        verbose::Bool = false,\n        stats::Union{Nothing, Dict} = nothing,\n)\n\nLarge Neighborhood Search applied to instance.\n\nEach iteration of the LNS is composed of:\n\nMulti-depot local search neighborhoods for descent.\nLarge neighborhoods: customer and commodity reinsertion,    using iterative_ruin_recreate_customer!    and iterative_ruin_recreate_commodity!,   as well as refill_routes! MILP-based moves.\n\nThe solution process can be stopped when the time elapsed is greater than  the time limit written in stats dictionnary.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.TSP_local_search!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.TSP_local_search!","text":"TSP_local_search!(instance::Instance;\n                    niter::Int = 1,\n                    verbose::Bool = false,\n                    stats::Union{Nothing, Dict} = nothing,\n                    in_LNS::Bool = true,\n)\n\nApply niter for loops on the routes of the solution of instance to apply iterative_TSP_neighborhood!.\n\nThe three types of TSP neighborhoods are tested.     The in_LNS boolean is used to choose in which category the statistics  are included (either in the greedy initialization heuristic if false  or the neighborhood of the LNS if true).\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.iterative_ruin_recreate_commodity!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_ruin_recreate_commodity!","text":"iterative_ruin_recreate_commodity!(instance::Instance;\n                                    niter::Int,\n                                    verbose::Bool = false,\n                                    stats::Union{Nothing, Dict} = nothing,\n                                    sort_by_length::Bool = false,\n                                    delete_empty_routes::Bool = true,\n)\n\nApply one_step_ruin_recreate_commodity! niter times on commodities. Two possibilities: select commodities at random, or by decreasing size.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.iterative_ruin_recreate_customer!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.iterative_ruin_recreate_customer!","text":"iterative_ruin_recreate_customer!(instance::Instance;\n                                    niter::Int,\n                                    verbose::Bool = false,\n                                    at_random::Bool = false,\n                                    stats::Union{Nothing, Dict} = nothing,\n)\n\nApply one_step_ruin_recreate_customer! niter times on customers. Two possibilities: select customers at random, or by decreasing cost order.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.multi_depot_local_search!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.multi_depot_local_search!","text":"multi_depot_local_search!(instance::Instance;\n                            niter::Int,\n                            verbose::Bool = false,\n                            stats::Union{Nothing, Dict} = nothing,\n                            in_LNS::Bool = true,\n)\n\nMulti-depot localsearch based on TSP, single-depot SDVRP and multi-depot SDVRP neighborhoods.\n\nWe pass niter times on each type of neighborhood.\n\n\n\n\n\n","category":"method"},{"location":"localsearch/#InventoryRoutingLNS.single_depot_local_search!-Tuple{InventoryRoutingLNS.Instance}","page":"Large Neighborhood Search","title":"InventoryRoutingLNS.single_depot_local_search!","text":"single_depot_local_search!(instance::Instance;\n                            maxdist::Real = Inf,\n                            niter::Int = 1,\n                            verbose::Bool = false,\n                            stats::Union{Nothing, Dict} = nothing,\n                            in_LNS::Bool = true,\n)\n\nSingle-depot localsearch based on merge, delete, insert and swap, and TSP neighborhoods.\n\nWe pass niter times on each type of neighborhood.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = InventoryRoutingLNS","category":"page"},{"location":"#InventoryRoutingLNS.jl","page":"Home","title":"InventoryRoutingLNS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for InventoryRoutingLNS.jl.","category":"page"},{"location":"#Get-started","page":"Home","title":"Get started","text":"","category":"section"},{"location":"#Continent-scale-multi-attribute-inventory-routing-problem","page":"Home","title":"Continent-scale multi-attribute inventory routing problem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims at solving large-scale multi-attribute inventory routing problems,  defined in Solving a Continent-Scale Inventory Routing Problem at Renault. In our setting, routes last several days, and the instances have 15 depots (Depot), 600 customers (Customer), 30 commodities (Commodity) and 21 days horizon  on average.  ","category":"page"},{"location":"#Solution-pipeline","page":"Home","title":"Solution pipeline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To create an IRP instance from a folder architecture, we call read_instance_CSV.  This function is designed to browse the CSV files and folders and create an instance (see Instance).\nA lower bound can be computed on the given instance using a flow relaxation, with lower_bound.\nThe initialization + local search algorithm is implemented as initialization_plus_ls!.  It can be applied with two passes, re-estimating the transport costs on the arcs of the commodity flow graphs   with a call to modified_capa_initialization_plus_ls!.\nThe large neighborhood search can then be applied to improve the initial solution with LNS!.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All this pipeline is encapsulated in the paper_matheuristic! function. The algorithm called route-based matheuristic in the paper is implemented as route_based_matheuristic!. Note that in the paper we call LNS the combination of initialization_plus_ls! and LNS! in our code.","category":"page"},{"location":"#Reproduce-the-results-of-the-article","page":"Home","title":"Reproduce the results of the article","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download the dataset of instances available here, unzip it and put it in the data/ folder of this repository.\nRun the main.jl as is to solve the 71 instances used for the numerical experiments of Solving a Continent-Scale Inventory Routing Problem at Renault.","category":"page"},{"location":"evaluation/#Cost,-feasibility-and-inventory-dynamics","page":"Evaluation","title":"Cost, feasibility and inventory dynamics","text":"","category":"section"},{"location":"evaluation/#Cost","page":"Evaluation","title":"Cost","text":"","category":"section"},{"location":"evaluation/","page":"Evaluation","title":"Evaluation","text":"Modules = [InventoryRoutingLNS]\nPages = [\"evaluation/cost.jl\"]","category":"page"},{"location":"evaluation/#InventoryRoutingLNS.compute_cost-Tuple{InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.compute_cost","text":"compute_cost(instance::Instance;\n                ds::Vector{Int} = collect(1:instance.D),\n                cs::Vector{Int} = collect(1:instance.C),\n                ms::Vector{Int} = collect(1:instance.M),\n                ts::Vector{Int} = collect(1:instance.T),\n                solution::Solution = instance.solution,\n                verbose::Bool = false,\n)\n\nCompute the total cost of the solution of instance, choose to print detailed results or not.\n\nTwo possible cases:\n\nverbose is true: we call compute_detailed_cost.\nverbose is false: we call compute_undetailed_cost.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.compute_detailed_cost-Tuple{InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.compute_detailed_cost","text":"compute_detailed_cost(instance::Instance;\n                        ds::Vector{Int} = collect(1:instance.D),\n                        cs::Vector{Int} = collect(1:instance.C),\n                        ms::Vector{Int} = collect(1:instance.M),\n                        ts::Vector{Int} = collect(1:instance.T),\n                        solution::Solution = instance.solution,\n)\n\nCompute the total cost of the solution of instance and print detailed results.\n\nSame principle as for compute_undetailed_cost but with statistics on the  decomposition of the cost. It may be useful for tests and investigation.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.compute_inventory_cost","page":"Evaluation","title":"InventoryRoutingLNS.compute_inventory_cost","text":"compute_inventory_cost(customer::Customer, t::Int, ms::Vector{Int} = collect(1:get_M(customer)))\n\nCompute the excess inventory cost of customer on day t for the commodities indexed by ms.\n\nThe excess inventory cost on day t for commodity m is defined as the product of the  number of commodities of type m above the maximum inventory and the unit excess cost.  The unit excess cost is defined for each customer on each day for each commodity. \n\n\n\n\n\n","category":"function"},{"location":"evaluation/#InventoryRoutingLNS.compute_inventory_cost-2","page":"Evaluation","title":"InventoryRoutingLNS.compute_inventory_cost","text":"compute_inventory_cost(customer::Customer, \n                        ms::Vector{Int} = collect(1:get_M(customer)), \n                        ts::Vector{Int} = collect(1:get_T(customer))\n)\n\nCompute the excess inventory cost of customer on the period ts for the commodities indexed by ms.\n\nWe sum the inventory costs of the commodities indexed by ms on the days ts.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#InventoryRoutingLNS.compute_inventory_cost-3","page":"Evaluation","title":"InventoryRoutingLNS.compute_inventory_cost","text":"compute_inventory_cost(depot::Depot, \n                        ms::Vector{Int} = collect(1:get_M(depot)), \n                        ts::Vector{Int} = collect(1:get_T(depot))\n)\n\nCompute the excess inventory cost of depot on the period ts for the commodities indexed by ms.\n\nWe sum the inventory costs of the commodities indexed by ms on the days ts. \n\n\n\n\n\n","category":"function"},{"location":"evaluation/#InventoryRoutingLNS.compute_inventory_cost-4","page":"Evaluation","title":"InventoryRoutingLNS.compute_inventory_cost","text":"compute_inventory_cost(depot::Depot, t::Int, ms::Vector{Int} = collect(1:get_M(depot)))\n\nCompute the excess inventory cost of depot on day t for the commodities indexed by ms.\n\nThe excess inventory cost on day t for commodity m is defined as the product of the  number of commodities of type m above the maximum inventory and the unit excess cost.  The unit excess cost is defined for each depot on each day for each commodity. \n\n\n\n\n\n","category":"function"},{"location":"evaluation/#InventoryRoutingLNS.compute_km_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.compute_km_cost","text":"compute_km_cost(route::Route, instance::Instance)\n\nCompute the kilometers' cost of route.\n\nThe kilometers' cost is defined as the product of the number of km  travelled and the unit km cost of instance. \n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.compute_route_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.compute_route_cost","text":"compute_route_cost(route::Route, instance::Instance)\n\nCompute the routing cost of route.\n\nThe routing cost is defined as the sum of the kilometers' cost, the stops' cost  and the vehicle cost. \n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.compute_shortage_cost","page":"Evaluation","title":"InventoryRoutingLNS.compute_shortage_cost","text":"compute_shortage_cost(customer::Customer, t::Int, ms::Vector{Int} = collect(1:get_M(customer)))\n\nCompute the shortage cost of customer on day t for the commodities indexed by ms.\n\nThe shortage cost on day t for commodity m is defined as the product of the  number of commodities of type m below the minimum inventory on the morning of day t  (thus inventory of the previous evening less the demand on day t) and the unit shortage cost.  The unit shortage cost is defined for each customer for each commodity. \n\n\n\n\n\n","category":"function"},{"location":"evaluation/#InventoryRoutingLNS.compute_shortage_cost-2","page":"Evaluation","title":"InventoryRoutingLNS.compute_shortage_cost","text":"compute_shortage_cost(customer::Customer, \n                        ms::Vector{Int} = collect(1:get_M(customer)), \n                        ts::Vector{Int} = collect(1:get_T(customer))\n)\n\nCompute the shortage cost of customer on the period ts for the commodities indexed by ms.\n\nWe sum the shortage costs of the commodities indexed by ms on the days ts.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#InventoryRoutingLNS.compute_stops_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.compute_stops_cost","text":"compute_stops_cost(route::Route, instance::Instance)\n\nCompute the stops' cost of route.\n\nThe stops' cost is defined as the product of the number of stops  and the unit cost of a stop of instance . \n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.compute_undetailed_cost-Tuple{InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.compute_undetailed_cost","text":"compute_undetailed_cost(instance::Instance;\n                        ds::Vector{Int} = collect(1:instance.D),\n                        cs::Vector{Int} = collect(1:instance.C),\n                        ms::Vector{Int} = collect(1:instance.M),\n                        ts::Vector{Int} = collect(1:instance.T),\n                        solution::Solution = instance.solution,\n)\n\nCompute the total cost of the solution of instance.\n\nThe total cost is defined as the sum of the routing costs, excess inventory costs at the depots and customers, and shortage costs at the customers. Notably for neighborhoods, when computing the cost, we may want to restrict the instance to:\n\nthe depots indexed by ds.\nthe customers indexed by cs.\nthe commodities indexed by ms.\nthe days ts. \n\n\n\n\n\n","category":"method"},{"location":"evaluation/#Feasibility","page":"Evaluation","title":"Feasibility","text":"","category":"section"},{"location":"evaluation/","page":"Evaluation","title":"Evaluation","text":"Modules = [InventoryRoutingLNS]\nPages = [\"evaluation/feasibility.jl\"]","category":"page"},{"location":"evaluation/#InventoryRoutingLNS.delays_coherent-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.delays_coherent","text":"delays_coherent(route::Route, instance::Instance; verbose::Bool = false)\n\nCheck if the dates of the deliveries of route are coherent with transport durations.\n\nIn the Instance structure, we have a maximum number of transport hours  per day nb_transport_hours_per_day, as well as the transport duration for each  site-to-site travel in transport_durations. We can therefore follow the path of  route and check if the dates and transport durations are coherent. \n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Customer}","page":"Evaluation","title":"InventoryRoutingLNS.feasibility","text":"feasibility(customer::Customer; verbose::Bool = false)\n\nCheck if the current solution of instance is feasible with respect to customer inventory.\n\nTwo conditions have to be verified:\n\nthe inventory is nonnegative for each commodity on each day.\nthe commodities received are restricted to those demanded.\n\nRemark: the second condition is necessary to avoid sending commdodities  to customers that do not need them to lower the excess inventory costs at the depots. \n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Depot}","page":"Evaluation","title":"InventoryRoutingLNS.feasibility","text":"feasibility(depot::Depot; verbose::Bool = false)\n\nCheck if the current solution of instance is feasible with respect to depot inventory.\n\nBefore applying this check, the instance and stored solution must be coherent. This can be made manually, or using update_instance_from_solution!. We then check if the depot inventory is nonnegative on each day for each commodity.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.feasibility","text":"feasibility(instance::Instance;\n            ds::Vector{Int} = collect(1:instance.D),\n            cs::Vector{Int} = collect(1:instance.C),\n            solution::Solution = instance.solution,\n            verbose::Bool = false,\n)\n\nCheck if solution is feasible for instance.\n\nFor this function to make sense, we need a coherence between the inventories  of the sites in instance and solution. It can be applied to the whole instance  updated with update_instance_from_solution!. It can also be applied locally to a sub-solution corresponding to  some routes and sub-sets of depots ds and customers cs, with inventories  updated using update_instance_some_routes!.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.feasibility","text":"feasibility(route::Route, instance::Instance; verbose::Bool = false)\n\nCheck if route is feasible for instance.\n\nA route is feasible if each of the following conditions is respected:\n\nthe number of stops does not exceed S_max.\nthe total content size of the deliveries is below the vehicle capacity.\nthe arrival date to the last stop is before the horizon T.\nthe dates of arrival in the stops are coherent with transport durations.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.stop_depot_not_compatible-Tuple{InventoryRoutingLNS.Depot, InventoryRoutingLNS.RouteStop}","page":"Evaluation","title":"InventoryRoutingLNS.stop_depot_not_compatible","text":"stop_depot_not_compatible(depot::Depot, stop::RouteStop; verbose::Bool = false)\n\nCheck if stop contains commodities not used by depot (no release or initial inventory).\n\nThis check is implicitly done by feasibility but faster to compute, we therefore  do not include it in the feasibility function of a depot, but instead call it when the whole  feasibility check is not necessary, see insert_multi_depot! for instance. \n\n\n\n\n\n","category":"method"},{"location":"evaluation/#Inventory-dynamics","page":"Evaluation","title":"Inventory dynamics","text":"","category":"section"},{"location":"evaluation/","page":"Evaluation","title":"Evaluation","text":"Modules = [InventoryRoutingLNS]\nPages = [\"evaluation/inventory.jl\"]","category":"page"},{"location":"evaluation/#InventoryRoutingLNS.coherence_solution_inventory-Tuple{InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.coherence_solution_inventory","text":"coherence_solution_inventory(instance::Instance)\n\nCheck the coherence between the fields of an instance and its solution.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.reset_solution!-Tuple{InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.reset_solution!","text":"reset_solution!(instance::Instance)\n\nReplace the solution of instance with an empty one and update inventory.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.solved_instance-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.Solution}","page":"Evaluation","title":"InventoryRoutingLNS.solved_instance","text":"solved_instance(instance::Instance, solution::Solution)\n\nCreate a solved copy of instance.\n\nOnly useful for additional checks after solving.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.update_instance_from_solution!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Evaluation","title":"InventoryRoutingLNS.update_instance_from_solution!","text":"update_instance_from_solution!(instance::Instance, m::Int)\n\nUpdate quantities and inventories of m from the routes of instance solution.\n\nWe first update quantities received and sent from the solution and then update  inventories from the quantities. \n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.update_instance_from_solution!-Tuple{InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.update_instance_from_solution!","text":"update_instance_from_solution!(instance::Instance)\n\nUpdate quantities and inventories of all commodities from the routes of instance solution.\n\nWe first update quantities received and sent from the solution and then update  inventories from the quantities. \n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.update_instance_some_routes!","page":"Evaluation","title":"InventoryRoutingLNS.update_instance_some_routes!","text":"update_instance_some_routes!(instance::Instance, \n                                routes::Vector{Route}, \n                                action::String, \n                                alter_solution::Bool=true\n)\n\nLocally update the instance inventories and quantities from routes.\n\nWe first apply update_quantities_some_routes! to update the quantities  locally depending on the action, then propagate the quantities to inventories with update_inventories_some_routes!. When alter_solution is true  we also add or delete the routes from the solution currently stored in the instance.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#InventoryRoutingLNS.update_inventories_some_routes!-Tuple{InventoryRoutingLNS.Instance, Vector{InventoryRoutingLNS.Route}}","page":"Evaluation","title":"InventoryRoutingLNS.update_inventories_some_routes!","text":"update_inventories_some_routes!(instance::Instance, routes::Vector{Route})\n\nLocally update the inventories from the quantities sent by routes.\n\nWe apply the same logic as in update_inventory_from_quantities! but restricted to the days, commodities, depots and customers that must be considered. The period affected is from the first departure date of the routes to the horizon T\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.update_inventory_from_quantities!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Evaluation","title":"InventoryRoutingLNS.update_inventory_from_quantities!","text":"update_inventory_from_quantities!(instance::Instance, m::Int)\n\nUpdate inventories of m at depots and customers from quantities sent and received.\n\nWhen the fields quantity_received and quantity_sent of instance are fixed,  the daily inventory at each depot and customer can be deduced using the proper dynamics.  We highlight the demand, release and routes departures are supposed to happen in the  morning, whereas the reception at the customers is in the evening. Inventories are  defined in the evening on each day.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.update_inventory_from_quantities!-Tuple{InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.update_inventory_from_quantities!","text":"update_inventory_from_quantities!(instance::Instance)\n\nUpdate inventories of all commodities at depots and customers from quantities sent and received.\n\nWhen the fields quantity_received and quantity_sent of instance are fixed,  the daily inventory at each depot and customer can be deduced using the proper dynamics.  We highlight the demand, release and routes departures are supposed to happen in the  morning, whereas the reception at the customers is in the evening. Inventories are  defined in the evening on each day.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.update_quantities_from_solution!-Tuple{InventoryRoutingLNS.Instance, Int64}","page":"Evaluation","title":"InventoryRoutingLNS.update_quantities_from_solution!","text":"update_quantities_from_solution!(instance::Instance, m::Int)\n\nUpdate daily quantities of commodity m sent and received from the instance solution.\n\nEach route in the solution of instance defines deliveries that can be aggregated  per customer and per depot on each day.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.update_quantities_from_solution!-Tuple{InventoryRoutingLNS.Instance}","page":"Evaluation","title":"InventoryRoutingLNS.update_quantities_from_solution!","text":"update_quantities_from_solution!(instance::Instance)\n\nUpdate daily quantities of all commodities sent and received from instance solution.\n\nEach route in the solution of instance defines deliveries that can be aggregated  per customer and per depot on each day.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#InventoryRoutingLNS.update_quantities_some_routes!-Tuple{InventoryRoutingLNS.Instance, Vector{InventoryRoutingLNS.Route}, String}","page":"Evaluation","title":"InventoryRoutingLNS.update_quantities_some_routes!","text":"update_quantities_some_routes!(instance::Instance, \n                                routes::Vector{Route}, \n                                action::String\n)\n\nLocally update the quantities sent and received from routes.\n\nWe apply the same logic as in update_quantities_from_solution! but restricted to the depots and customers that are involved in routes. Depending on action, the quantities induced by routes can be added or removed.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#Input-Output","page":"Input-Output","title":"Input-Output","text":"","category":"section"},{"location":"input_output/#Input","page":"Input-Output","title":"Input","text":"","category":"section"},{"location":"input_output/","page":"Input-Output","title":"Input-Output","text":"Modules = [InventoryRoutingLNS]\nPages = [\"input_output/import.jl\"]","category":"page"},{"location":"input_output/#InventoryRoutingLNS.read_commodities_CSV-Tuple{String}","page":"Input-Output","title":"InventoryRoutingLNS.read_commodities_CSV","text":"read_commodities_CSV(path::String)\n\nCreate a vector of commodities from a CSV file.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_commodity-Tuple{String, NamedTuple}","page":"Input-Output","title":"InventoryRoutingLNS.read_commodity","text":"read_commodity(row::String, dims::NamedTuple)::Commodity\n\nCreate a commodity from a row of a text file.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_customer-Tuple{String, NamedTuple}","page":"Input-Output","title":"InventoryRoutingLNS.read_customer","text":"read_customer(row::String, dims::NamedTuple)::Customer\n\nCreate a customer from a text file.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_customers_CSV-Tuple{String, NamedTuple, Vector{String}, Vector{Int64}}","page":"Input-Output","title":"InventoryRoutingLNS.read_customers_CSV","text":"read_customers_CSV(path::String,\n                    dims::NamedTuple,\n                    commodity_codes::Vector{String},\n                    v_index_to_code::Vector{Int},\n)\n\nCreate a vector of customers from CSV files.\n\nIn each customer folder, there is one master data file, one file on maximum stock  per commodity and per day, one file for the demand per commodity and day,  and one file for the initial inventory, unit excess and unit shortage cost per commodity.  All of them are CSV files that can be easily converted into arrays.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_depot-Tuple{String, NamedTuple}","page":"Input-Output","title":"InventoryRoutingLNS.read_depot","text":"read_depot(row::String, dims::NamedTuple)::Depot\n\nCreate a depot from a text file.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_depots_CSV-Tuple{String, NamedTuple, Vector{String}}","page":"Input-Output","title":"InventoryRoutingLNS.read_depots_CSV","text":"read_depots_CSV(path::String, dims::NamedTuple, commodity_codes::Vector{String})\n\nCreate a vector of depots from CSV files.\n\nIn each depot folder, there is one master data file, one file on maximum stock  per commodity and per day, one file for the release per commodity and day,  and one file for the initial inventory and unit excess inventory cost per commodity.  All of them are CSV files that can be easily converted into arrays.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_dimensions-Tuple{String}","page":"Input-Output","title":"InventoryRoutingLNS.read_dimensions","text":"read_dimensions(row::String)::NamedTuple\n\nRead the global data of an instance from a text file.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_dimensions_CSV-Tuple{String}","page":"Input-Output","title":"InventoryRoutingLNS.read_dimensions_CSV","text":"read_dimensions_CSV(path::String)::NamedTuple\n\nRead the global data of an instance from a CSV file.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_distances-Tuple{Vector{String}, NamedTuple}","page":"Input-Output","title":"InventoryRoutingLNS.read_distances","text":"read_distances(rows::Vector{String}, dims::NamedTuple)::Matrix{Int}\n\nGet the distances matrix from a text file.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_distances_CSV-Tuple{String, NamedTuple, Vector{Int64}}","page":"Input-Output","title":"InventoryRoutingLNS.read_distances_CSV","text":"read_distances_CSV(path::String, dims::NamedTuple, v_index_to_code::Vector{Int})\n\nGet the distances matrix from a CSV file.\n\nWe check that the indices of the rows and columns indeed correspond to  the sites indices used when reading depots and customers.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_instance-Tuple{String}","page":"Input-Output","title":"InventoryRoutingLNS.read_instance","text":"read_instance(path::String)::Instance\n\nCreate a whole instance from a text file.\n\nThis function is only used on the KIRO instances (smaller and used for tests). Real instances are read from CSV files,  see read_instance_CSV. \n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_instance_CSV-Tuple{String}","page":"Input-Output","title":"InventoryRoutingLNS.read_instance_CSV","text":"read_instance_CSV(path_to_folder::String)::Instance\n\nCreate an instance from CSV files.\n\nAn instance folder has:\n\none master data file.\none file on commodities.\none file on customers indices.\none file on depots indices.\none file on distances.\none file on transport durations.\none folder per customer.\none folder per depot.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_route-Tuple{String}","page":"Input-Output","title":"InventoryRoutingLNS.read_route","text":"read_route(row::String)::Route\n\nCreate a route from a row of a text file.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_solution-Tuple{String}","page":"Input-Output","title":"InventoryRoutingLNS.read_solution","text":"read_solution(path::String)::SimpleSolution\n\nCreate a simple solution from a text file.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_transport_durations-Tuple{Vector{String}, NamedTuple}","page":"Input-Output","title":"InventoryRoutingLNS.read_transport_durations","text":"read_transport_durations(rows::Vector{String}, dims::NamedTuple)::Matrix{Int}\n\nGet the transport durations matrix from a distances text file.\n\nWe assume a constant speed model here.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.read_transport_durations_CSV-Tuple{String, NamedTuple, Vector{Int64}}","page":"Input-Output","title":"InventoryRoutingLNS.read_transport_durations_CSV","text":"read_transport_durations_CSV(path::String, dims::NamedTuple, v_index_to_code::Vector{Int})\n\nGet the transport durations matrix from a CSV file.\n\nWe check that the indices of the rows and columns indeed correspond to  the sites indices used when reading depots and customers.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#Output","page":"Input-Output","title":"Output","text":"","category":"section"},{"location":"input_output/","page":"Input-Output","title":"Input-Output","text":"Modules = [InventoryRoutingLNS]\nPages = [\"input_output/export.jl\"]","category":"page"},{"location":"input_output/#InventoryRoutingLNS.Distances","page":"Input-Output","title":"InventoryRoutingLNS.Distances","text":"Distances\n\nStore the site-to-site distances. \n\nFields\n\ndist::Matrix{Int}: distances matrix (km).\n\n\n\n\n\n","category":"type"},{"location":"input_output/#Base.string-Tuple{InventoryRoutingLNS.Commodity}","page":"Input-Output","title":"Base.string","text":"Base.string(commodity::Commodity)::String\n\nEncode commodity in a string.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#Base.string-Tuple{InventoryRoutingLNS.Customer}","page":"Input-Output","title":"Base.string","text":"Base.string(customer::Customer)::String\n\nEncode customer in a string.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#Base.string-Tuple{InventoryRoutingLNS.Depot}","page":"Input-Output","title":"Base.string","text":"Base.string(depot::Depot)::String\n\nEncode depot in a string.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#Base.string-Tuple{InventoryRoutingLNS.Distances}","page":"Input-Output","title":"Base.string","text":"Base.string(distances::Distances)::String\n\nEncode site-to-site distances in a string.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#Base.string-Tuple{InventoryRoutingLNS.Route, Int64}","page":"Input-Output","title":"Base.string","text":"Base.string(route::Route, r::Int)::String\n\nEncode route in a string.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#Base.string-Tuple{InventoryRoutingLNS.RouteStop}","page":"Input-Output","title":"Base.string","text":"Base.string(stop::RouteStop)::String\n\nEncode route stop in a string.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.write_detailed_cost-Tuple{}","page":"Input-Output","title":"InventoryRoutingLNS.write_detailed_cost","text":"write_detailed_cost(; cost_dict, path_to_folder::String, name::String)\n\nWrite a detailed cost in a JSON file.\n\nThe detailed cost is studied at various steps of paper_matheuristic!.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.write_instance-Tuple{InventoryRoutingLNS.Instance, String}","page":"Input-Output","title":"InventoryRoutingLNS.write_instance","text":"write_instance(instance::Instance, path::String)\n\nEncode instance in a text file at path location.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.write_lower_bounds-Tuple{String, Bool}","page":"Input-Output","title":"InventoryRoutingLNS.write_lower_bounds","text":"write_lower_bounds(path_to_folder::String, rescale::Bool)\n\nCompute and write all the lower bounds on the IRP instances contained in a folder.\n\nWe possibly rescale instances with rescale_release_demand!. The lower bounds are computed with the flow relaxation lower_bound.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.write_solution-Tuple{InventoryRoutingLNS.Instance, String}","page":"Input-Output","title":"InventoryRoutingLNS.write_solution","text":"write_solution(instance::Instance, path::String)\n\nEncode the solution stored in instance in a file at path location.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.write_solution-Tuple{InventoryRoutingLNS.Solution, String}","page":"Input-Output","title":"InventoryRoutingLNS.write_solution","text":"write_solution(solution::Solution, path::String)\n\nEncode solution in a file at path location.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#InventoryRoutingLNS.write_stats-Tuple{}","page":"Input-Output","title":"InventoryRoutingLNS.write_stats","text":"write_stats(; stats::Dict = nothing, path_to_folder::String)\n\nWrite the stats of the solution process in a JSON file for analysis.\n\nThe stats are computed during optimization and defined in paper_matheuristic!.\n\n\n\n\n\n","category":"method"}]
}
