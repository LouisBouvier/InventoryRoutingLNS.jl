<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Evaluation · InventoryRoutingLNS.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://LouisBouvier.github.io/InventoryRoutingLNS.jl/evaluation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">InventoryRoutingLNS.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../IRP/">Inventory Routing Problem</a></li><li><a class="tocitem" href="../input_output/">Input-Output</a></li><li class="is-active"><a class="tocitem" href>Evaluation</a><ul class="internal"><li><a class="tocitem" href="#Cost"><span>Cost</span></a></li><li><a class="tocitem" href="#Feasibility"><span>Feasibility</span></a></li><li><a class="tocitem" href="#Inventory-dynamics"><span>Inventory dynamics</span></a></li></ul></li><li><a class="tocitem" href="../flows/">Flows and Graphs</a></li><li><a class="tocitem" href="../utils/">Utils</a></li><li><a class="tocitem" href="../localsearch/">Large Neighborhood Search</a></li><li><a class="tocitem" href="../heuristics/">Heuristics</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Evaluation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Evaluation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/main/docs/src/evaluation.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Cost,-feasibility-and-inventory-dynamics"><a class="docs-heading-anchor" href="#Cost,-feasibility-and-inventory-dynamics">Cost, feasibility and inventory dynamics</a><a id="Cost,-feasibility-and-inventory-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Cost,-feasibility-and-inventory-dynamics" title="Permalink"></a></h1><h2 id="Cost"><a class="docs-heading-anchor" href="#Cost">Cost</a><a id="Cost-1"></a><a class="docs-heading-anchor-permalink" href="#Cost" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_cost-Tuple{InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.compute_cost-Tuple{InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.compute_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_cost(instance::Instance;
                ds::Vector{Int} = collect(1:instance.D),
                cs::Vector{Int} = collect(1:instance.C),
                ms::Vector{Int} = collect(1:instance.M),
                ts::Vector{Int} = collect(1:instance.T),
                solution::Solution = instance.solution,
                verbose::Bool = false,
)</code></pre><p>Compute the total cost of the <code>solution</code> of <code>instance</code>, choose to print detailed results or not.</p><p>Two possible cases:</p><ul><li><code>verbose</code> is <code>true</code>: we call <a href="#InventoryRoutingLNS.compute_detailed_cost-Tuple{InventoryRoutingLNS.Instance}"><code>compute_detailed_cost</code></a>.</li><li><code>verbose</code> is <code>false</code>: we call <a href="#InventoryRoutingLNS.compute_undetailed_cost-Tuple{InventoryRoutingLNS.Instance}"><code>compute_undetailed_cost</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L288-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_detailed_cost-Tuple{InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.compute_detailed_cost-Tuple{InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.compute_detailed_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_detailed_cost(instance::Instance;
                        ds::Vector{Int} = collect(1:instance.D),
                        cs::Vector{Int} = collect(1:instance.C),
                        ms::Vector{Int} = collect(1:instance.M),
                        ts::Vector{Int} = collect(1:instance.T),
                        solution::Solution = instance.solution,
)</code></pre><p>Compute the total cost of the <code>solution</code> of <code>instance</code> and print detailed results.</p><p>Same principle as for <a href="#InventoryRoutingLNS.compute_undetailed_cost-Tuple{InventoryRoutingLNS.Instance}"><code>compute_undetailed_cost</code></a> but with statistics on the  decomposition of the cost. It may be useful for tests and investigation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L211-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_inventory_cost" href="#InventoryRoutingLNS.compute_inventory_cost"><code>InventoryRoutingLNS.compute_inventory_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_inventory_cost(customer::Customer, 
                        ms::Vector{Int} = collect(1:get_M(customer)), 
                        ts::Vector{Int} = collect(1:get_T(customer))
)</code></pre><p>Compute the excess inventory cost of <code>customer</code> on the period <code>ts</code> for the commodities indexed by <code>ms</code>.</p><p>We sum the inventory costs of the commodities indexed by <code>ms</code> on the days <code>ts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L107-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_inventory_cost" href="#InventoryRoutingLNS.compute_inventory_cost"><code>InventoryRoutingLNS.compute_inventory_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_inventory_cost(depot::Depot, 
                        ms::Vector{Int} = collect(1:get_M(depot)), 
                        ts::Vector{Int} = collect(1:get_T(depot))
)</code></pre><p>Compute the excess inventory cost of <code>depot</code> on the period <code>ts</code> for the commodities indexed by <code>ms</code>.</p><p>We sum the inventory costs of the commodities indexed by <code>ms</code> on the days <code>ts</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L66-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_inventory_cost" href="#InventoryRoutingLNS.compute_inventory_cost"><code>InventoryRoutingLNS.compute_inventory_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_inventory_cost(depot::Depot, t::Int, ms::Vector{Int} = collect(1:get_M(depot)))</code></pre><p>Compute the excess inventory cost of <code>depot</code> on day <code>t</code> for the commodities indexed by <code>ms</code>.</p><p>The excess inventory cost on day <code>t</code> for commodity <code>m</code> is defined as the product of the  number of commodities of type <code>m</code> above the maximum inventory and the unit excess cost.  The unit excess cost is defined for each depot on each day for each commodity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L45-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_inventory_cost" href="#InventoryRoutingLNS.compute_inventory_cost"><code>InventoryRoutingLNS.compute_inventory_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_inventory_cost(customer::Customer, t::Int, ms::Vector{Int} = collect(1:get_M(customer)))</code></pre><p>Compute the excess inventory cost of <code>customer</code> on day <code>t</code> for the commodities indexed by <code>ms</code>.</p><p>The excess inventory cost on day <code>t</code> for commodity <code>m</code> is defined as the product of the  number of commodities of type <code>m</code> above the maximum inventory and the unit excess cost.  The unit excess cost is defined for each customer on each day for each commodity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_km_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.compute_km_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.compute_km_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_km_cost(route::Route, instance::Instance)</code></pre><p>Compute the kilometers&#39; cost of <code>route</code>.</p><p>The kilometers&#39; cost is defined as the product of the number of km  travelled and the unit km cost of <code>instance</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_route_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.compute_route_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.compute_route_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_route_cost(route::Route, instance::Instance)</code></pre><p>Compute the routing cost of <code>route</code>.</p><p>The routing cost is defined as the sum of the kilometers&#39; cost, the stops&#39; cost  and the vehicle cost. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_shortage_cost" href="#InventoryRoutingLNS.compute_shortage_cost"><code>InventoryRoutingLNS.compute_shortage_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_shortage_cost(customer::Customer, 
                        ms::Vector{Int} = collect(1:get_M(customer)), 
                        ts::Vector{Int} = collect(1:get_T(customer))
)</code></pre><p>Compute the shortage cost of <code>customer</code> on the period <code>ts</code> for the commodities indexed by <code>ms</code>.</p><p>We sum the shortage costs of the commodities indexed by <code>ms</code> on the days <code>ts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_shortage_cost" href="#InventoryRoutingLNS.compute_shortage_cost"><code>InventoryRoutingLNS.compute_shortage_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_shortage_cost(customer::Customer, t::Int, ms::Vector{Int} = collect(1:get_M(customer)))</code></pre><p>Compute the shortage cost of <code>customer</code> on day <code>t</code> for the commodities indexed by <code>ms</code>.</p><p>The shortage cost on day <code>t</code> for commodity <code>m</code> is defined as the product of the  number of commodities of type <code>m</code> below the minimum inventory on the morning of day <code>t</code>  (thus inventory of the previous evening less the demand on day <code>t</code>) and the unit shortage cost.  The unit shortage cost is defined for each customer for each commodity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L125-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_stops_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.compute_stops_cost-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.compute_stops_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_stops_cost(route::Route, instance::Instance)</code></pre><p>Compute the stops&#39; cost of <code>route</code>.</p><p>The stops&#39; cost is defined as the product of the number of stops  and the unit cost of a stop of <code>instance</code> . </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.compute_undetailed_cost-Tuple{InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.compute_undetailed_cost-Tuple{InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.compute_undetailed_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_undetailed_cost(instance::Instance;
                        ds::Vector{Int} = collect(1:instance.D),
                        cs::Vector{Int} = collect(1:instance.C),
                        ms::Vector{Int} = collect(1:instance.M),
                        ts::Vector{Int} = collect(1:instance.T),
                        solution::Solution = instance.solution,
)</code></pre><p>Compute the total cost of the <code>solution</code> of <code>instance</code>.</p><p>The total cost is defined as the sum of the routing costs, excess inventory costs at the depots and customers, and shortage costs at the customers. Notably for neighborhoods, when computing the cost, we may want to restrict the <code>instance</code> to:</p><ul><li>the depots indexed by <code>ds</code>.</li><li>the customers indexed by <code>cs</code>.</li><li>the commodities indexed by <code>ms</code>.</li><li>the days <code>ts</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/cost.jl#L170-L188">source</a></section></article><h2 id="Feasibility"><a class="docs-heading-anchor" href="#Feasibility">Feasibility</a><a id="Feasibility-1"></a><a class="docs-heading-anchor-permalink" href="#Feasibility" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.delays_coherent-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.delays_coherent-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.delays_coherent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delays_coherent(route::Route, instance::Instance; verbose::Bool = false)</code></pre><p>Check if the dates of the deliveries of <code>route</code> are coherent with transport durations.</p><p>In the <a href="../IRP/#InventoryRoutingLNS.Instance"><code>Instance</code></a> structure, we have a maximum number of transport hours  per day <code>nb_transport_hours_per_day</code>, as well as the transport duration for each  site-to-site travel in <code>transport_durations</code>. We can therefore follow the path of  <code>route</code> and check if the dates and transport durations are coherent. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/feasibility.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Customer}" href="#InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Customer}"><code>InventoryRoutingLNS.feasibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feasibility(customer::Customer; verbose::Bool = false)</code></pre><p>Check if the current solution of <code>instance</code> is feasible with respect to <code>customer</code> inventory.</p><p>Two conditions have to be verified:</p><ul><li>the inventory is nonnegative for each commodity on each day.</li><li>the commodities received are restricted to those demanded.</li></ul><p>Remark: the second condition is necessary to avoid sending commdodities  to customers that do not need them to lower the excess inventory costs at the depots. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/feasibility.jl#L104-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Depot}" href="#InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Depot}"><code>InventoryRoutingLNS.feasibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feasibility(depot::Depot; verbose::Bool = false)</code></pre><p>Check if the current solution of <code>instance</code> is feasible with respect to <code>depot</code> inventory.</p><p>Before applying this check, the <code>instance</code> and stored <code>solution</code> must be coherent. This can be made manually, or using <a href="#InventoryRoutingLNS.update_instance_from_solution!-Tuple{InventoryRoutingLNS.Instance, Int64}"><code>update_instance_from_solution!</code></a>. We then check if the depot inventory is nonnegative on each day for each commodity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/feasibility.jl#L71-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.feasibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feasibility(instance::Instance;
            ds::Vector{Int} = collect(1:instance.D),
            cs::Vector{Int} = collect(1:instance.C),
            solution::Solution = instance.solution,
            verbose::Bool = false,
)</code></pre><p>Check if <code>solution</code> is feasible for <code>instance</code>.</p><p>For this function to make sense, we need a coherence between the inventories  of the sites in <code>instance</code> and <code>solution</code>. It can be applied to the whole instance  updated with <a href="#InventoryRoutingLNS.update_instance_from_solution!-Tuple{InventoryRoutingLNS.Instance, Int64}"><code>update_instance_from_solution!</code></a>. It can also be applied locally to a sub-solution corresponding to  some routes and sub-sets of depots <code>ds</code> and customers <code>cs</code>, with inventories  updated using <a href="#InventoryRoutingLNS.update_instance_some_routes!"><code>update_instance_some_routes!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/feasibility.jl#L130-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Route, InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.feasibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feasibility(route::Route, instance::Instance; verbose::Bool = false)</code></pre><p>Check if <code>route</code> is feasible for <code>instance</code>.</p><p>A route is feasible if each of the following conditions is respected:</p><ul><li>the number of stops does not exceed <code>S_max</code>.</li><li>the total content size of the deliveries is below the vehicle capacity.</li><li>the arrival date to the last stop is before the horizon <code>T</code>.</li><li>the dates of arrival in the stops are coherent with transport durations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/feasibility.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.stop_depot_not_compatible-Tuple{InventoryRoutingLNS.Depot, InventoryRoutingLNS.RouteStop}" href="#InventoryRoutingLNS.stop_depot_not_compatible-Tuple{InventoryRoutingLNS.Depot, InventoryRoutingLNS.RouteStop}"><code>InventoryRoutingLNS.stop_depot_not_compatible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stop_depot_not_compatible(depot::Depot, stop::RouteStop; verbose::Bool = false)</code></pre><p>Check if <code>stop</code> contains commodities not used by <code>depot</code> (no release or initial inventory).</p><p>This check is implicitly done by <a href="#InventoryRoutingLNS.feasibility-Tuple{InventoryRoutingLNS.Customer}"><code>feasibility</code></a> but faster to compute, we therefore  do not include it in the feasibility function of a depot, but instead call it when the whole  feasibility check is not necessary, see <a href="../localsearch/#InventoryRoutingLNS.insert_multi_depot!-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.Route, InventoryRoutingLNS.Route, Int64}"><code>insert_multi_depot!</code></a> for instance. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/feasibility.jl#L89-L97">source</a></section></article><h2 id="Inventory-dynamics"><a class="docs-heading-anchor" href="#Inventory-dynamics">Inventory dynamics</a><a id="Inventory-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Inventory-dynamics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.coherence_solution_inventory-Tuple{InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.coherence_solution_inventory-Tuple{InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.coherence_solution_inventory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coherence_solution_inventory(instance::Instance)</code></pre><p>Check the coherence between the fields of an instance and its solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.reset_solution!-Tuple{InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.reset_solution!-Tuple{InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.reset_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_solution!(instance::Instance)</code></pre><p>Replace the solution of <code>instance</code> with an empty one and update inventory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.solved_instance-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.Solution}" href="#InventoryRoutingLNS.solved_instance-Tuple{InventoryRoutingLNS.Instance, InventoryRoutingLNS.Solution}"><code>InventoryRoutingLNS.solved_instance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solved_instance(instance::Instance, solution::Solution)</code></pre><p>Create a solved copy of <code>instance</code>.</p><p>Only useful for additional checks after solving.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.update_instance_from_solution!-Tuple{InventoryRoutingLNS.Instance, Int64}" href="#InventoryRoutingLNS.update_instance_from_solution!-Tuple{InventoryRoutingLNS.Instance, Int64}"><code>InventoryRoutingLNS.update_instance_from_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_instance_from_solution!(instance::Instance, m::Int)</code></pre><p>Update quantities and inventories of <code>m</code> from the routes of <code>instance</code> solution.</p><p>We first update quantities received and sent from the solution and then update  inventories from the quantities. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.update_instance_from_solution!-Tuple{InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.update_instance_from_solution!-Tuple{InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.update_instance_from_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_instance_from_solution!(instance::Instance)</code></pre><p>Update quantities and inventories of all commodities from the routes of <code>instance</code> solution.</p><p>We first update quantities received and sent from the solution and then update  inventories from the quantities. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.update_instance_some_routes!" href="#InventoryRoutingLNS.update_instance_some_routes!"><code>InventoryRoutingLNS.update_instance_some_routes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_instance_some_routes!(instance::Instance, 
                                routes::Vector{Route}, 
                                action::String, 
                                alter_solution::Bool=true
)</code></pre><p>Locally update the <code>instance</code> inventories and quantities from <code>routes</code>.</p><p>We first apply <a href="#InventoryRoutingLNS.update_quantities_some_routes!-Tuple{InventoryRoutingLNS.Instance, Vector{InventoryRoutingLNS.Route}, String}"><code>update_quantities_some_routes!</code></a> to update the quantities  locally depending on the <code>action</code>, then propagate the quantities to inventories with <a href="#InventoryRoutingLNS.update_inventories_some_routes!-Tuple{InventoryRoutingLNS.Instance, Vector{InventoryRoutingLNS.Route}}"><code>update_inventories_some_routes!</code></a>. When <code>alter_solution</code> is true  we also add or delete the <code>routes</code> from the solution currently stored in the <code>instance</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L255-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.update_inventories_some_routes!-Tuple{InventoryRoutingLNS.Instance, Vector{InventoryRoutingLNS.Route}}" href="#InventoryRoutingLNS.update_inventories_some_routes!-Tuple{InventoryRoutingLNS.Instance, Vector{InventoryRoutingLNS.Route}}"><code>InventoryRoutingLNS.update_inventories_some_routes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_inventories_some_routes!(instance::Instance, routes::Vector{Route})</code></pre><p>Locally update the inventories from the quantities sent by <code>routes</code>.</p><p>We apply the same logic as in <a href="#InventoryRoutingLNS.update_inventory_from_quantities!-Tuple{InventoryRoutingLNS.Instance, Int64}"><code>update_inventory_from_quantities!</code></a> but restricted to the days, commodities, depots and customers that must be considered. The period affected is from the first departure date of the <code>routes</code> to the horizon <code>T</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L204-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.update_inventory_from_quantities!-Tuple{InventoryRoutingLNS.Instance, Int64}" href="#InventoryRoutingLNS.update_inventory_from_quantities!-Tuple{InventoryRoutingLNS.Instance, Int64}"><code>InventoryRoutingLNS.update_inventory_from_quantities!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_inventory_from_quantities!(instance::Instance, m::Int)</code></pre><p>Update inventories of <code>m</code> at depots and customers from quantities sent and received.</p><p>When the fields <code>quantity_received</code> and <code>quantity_sent</code> of <code>instance</code> are fixed,  the daily inventory at each depot and customer can be deduced using the proper dynamics.  We highlight the demand, release and routes departures are supposed to happen in the  morning, whereas the reception at the customers is in the evening. Inventories are  defined in the evening on each day.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L34-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.update_inventory_from_quantities!-Tuple{InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.update_inventory_from_quantities!-Tuple{InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.update_inventory_from_quantities!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_inventory_from_quantities!(instance::Instance)</code></pre><p>Update inventories of all commodities at depots and customers from quantities sent and received.</p><p>When the fields <code>quantity_received</code> and <code>quantity_sent</code> of <code>instance</code> are fixed,  the daily inventory at each depot and customer can be deduced using the proper dynamics.  We highlight the demand, release and routes departures are supposed to happen in the  morning, whereas the reception at the customers is in the evening. Inventories are  defined in the evening on each day.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L93-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.update_quantities_from_solution!-Tuple{InventoryRoutingLNS.Instance, Int64}" href="#InventoryRoutingLNS.update_quantities_from_solution!-Tuple{InventoryRoutingLNS.Instance, Int64}"><code>InventoryRoutingLNS.update_quantities_from_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_quantities_from_solution!(instance::Instance, m::Int)</code></pre><p>Update daily quantities of commodity <code>m</code> sent and received from the <code>instance</code> solution.</p><p>Each route in the solution of <code>instance</code> defines deliveries that can be aggregated  per customer and per depot on each day.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.update_quantities_from_solution!-Tuple{InventoryRoutingLNS.Instance}" href="#InventoryRoutingLNS.update_quantities_from_solution!-Tuple{InventoryRoutingLNS.Instance}"><code>InventoryRoutingLNS.update_quantities_from_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_quantities_from_solution!(instance::Instance)</code></pre><p>Update daily quantities of all commodities sent and received from <code>instance</code> solution.</p><p>Each route in the solution of <code>instance</code> defines deliveries that can be aggregated  per customer and per depot on each day.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InventoryRoutingLNS.update_quantities_some_routes!-Tuple{InventoryRoutingLNS.Instance, Vector{InventoryRoutingLNS.Route}, String}" href="#InventoryRoutingLNS.update_quantities_some_routes!-Tuple{InventoryRoutingLNS.Instance, Vector{InventoryRoutingLNS.Route}, String}"><code>InventoryRoutingLNS.update_quantities_some_routes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_quantities_some_routes!(instance::Instance, 
                                routes::Vector{Route}, 
                                action::String
)</code></pre><p>Locally update the quantities sent and received from <code>routes</code>.</p><p>We apply the same logic as in <a href="#InventoryRoutingLNS.update_quantities_from_solution!-Tuple{InventoryRoutingLNS.Instance, Int64}"><code>update_quantities_from_solution!</code></a> but restricted to the depots and customers that are involved in <code>routes</code>. Depending on <code>action</code>, the quantities induced by <code>routes</code> can be added or removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LouisBouvier/InventoryRoutingLNS.jl/blob/797cbe5b03e670406bb98b70c306d3c5564aeff4/src/evaluation/inventory.jl#L160-L171">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../input_output/">« Input-Output</a><a class="docs-footer-nextpage" href="../flows/">Flows and Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 19 July 2023 12:20">Wednesday 19 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
